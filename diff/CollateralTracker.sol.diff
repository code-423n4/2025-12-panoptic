diff --git a/contracts/CollateralTracker.sol b/contracts/CollateralTracker.sol
index 84f4a55f..e6fbd6ea 100644
--- a/contracts/CollateralTracker.sol
+++ b/contracts/CollateralTracker.sol
@@ -1,26 +1,24 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.24;
-
 // Interfaces
 import {PanopticPool} from "./PanopticPool.sol";
+import {IRiskEngine} from "@contracts/interfaces/IRiskEngine.sol";
+import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
 // Inherited implementations
 import {Clone} from "clones-with-immutable-args/Clone.sol";
 import {ERC20Minimal} from "@tokens/ERC20Minimal.sol";
-import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
 import {Multicall} from "@base/Multicall.sol";
 // Libraries
-import {Constants} from "@libraries/Constants.sol";
 import {Errors} from "@libraries/Errors.sol";
 import {InteractionHelper} from "@libraries/InteractionHelper.sol";
 import {Math} from "@libraries/Math.sol";
-import {PanopticMath} from "@libraries/PanopticMath.sol";
 import {SafeTransferLib} from "@libraries/SafeTransferLib.sol";
 // Custom types
 import {Currency} from "v4-core/types/Currency.sol";
-import {LeftRightUnsigned, LeftRightSigned} from "@types/LeftRight.sol";
-import {LiquidityChunk} from "@types/LiquidityChunk.sol";
-import {PositionBalance} from "@types/PositionBalance.sol";
+import {LeftRightSigned} from "@types/LeftRight.sol";
 import {TokenId} from "@types/TokenId.sol";
+import {RiskParameters} from "@types/RiskParameters.sol";
+import {MarketState, MarketStateLibrary} from "@types/MarketState.sol";
 
 /// @title Collateral Tracking System / Margin Accounting used in conjunction with a Panoptic Pool.
 /// @author Axicon Labs Limited
@@ -65,6 +63,36 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         uint256 shares
     );
 
+    /// @notice Emitted when shares are donated to the protocol.
+    /// @param sender The address of the caller
+    /// @param shares The amount of shares burned by the sender
+    event Donate(address indexed sender, uint256 shares);
+
+    /// @notice Emitted when a commission is paid.
+    /// @param owner The address of the owner of the shares being used to pay for the commission
+    /// @param builder The address of the account that received the commission if a builderCode is provided
+    /// @param commissionPaidProtocol The amount of assets paid that goes to the PLPs (if builder == address(0)) or to the protocol
+    /// @param commissionPaidBuilder The amount of assets paid that goes to the builder
+    event CommissionPaid(
+        address indexed owner,
+        address indexed builder,
+        uint128 commissionPaidProtocol,
+        uint128 commissionPaidBuilder
+    );
+
+    /// @notice Emitted when a user attempts to settle interest but lacks sufficient shares to pay in full.
+    /// @dev The user's borrow index is not updated, meaning they will need to pay this interest again in the future.
+    /// @param owner The address of the insolvent user
+    /// @param interestOwed The total amount of interest the user owed
+    /// @param interestPaid The actual amount of interest paid (value of shares burned)
+    /// @param sharesBurned The number of shares burned in the partial payment
+    event InsolvencyPenaltyApplied(
+        address indexed owner,
+        uint256 interestOwed,
+        uint256 interestPaid,
+        uint256 sharesBurned
+    );
+
     /*//////////////////////////////////////////////////////////////
                                CONSTANTS
     //////////////////////////////////////////////////////////////*/
@@ -72,67 +100,45 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @notice Prefix for the token symbol (i.e. poUSDC).
     string internal constant TICKER_PREFIX = "po";
 
-    /// @notice Prefix for the token name (i.e POPT-V1.1 USDC LP on ETH/USDC 30bps).
-    string internal constant NAME_PREFIX = "POPT-V1.1";
+    /// @notice Prefix for the token name (i.e POPT-V1 USDC LP on ETH/USDC 30bps).
+    string internal constant NAME_PREFIX = "POPT-V1";
 
-    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
+    /// @notice Decimals for computation (1 bps (1 basis point) precision: 0.01%).
     /// @dev uint type for composability with unsigned integer based mathematical operations.
     uint256 internal constant DECIMALS = 10_000;
 
-    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
-    /// @dev int type for composability with signed integer based mathematical operations.
-    int128 internal constant DECIMALS_128 = 10_000;
+    /// @notice Decimals for WAD calculations.
+    uint256 internal constant WAD = 1e18;
 
-    /*//////////////////////////////////////////////////////////////
-                            RISK PARAMETERS
-    //////////////////////////////////////////////////////////////*/
+    /// @notice Mask zero the value between bits 112 and 150);
+    uint256 internal constant TARGET_RATE_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFFFFFFC000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF;
 
-    /// @notice The commission fee, in basis points, collected from PLPs at option mint.
-    /// @dev In Panoptic, options never expire, commissions are only paid when a new position is minted.
-    /// @dev We believe that this will eliminate the impact of the commission fee on the user's decision-making process when closing a position.
-    uint256 immutable COMMISSION_FEE;
-
-    /// @notice Required collateral ratios for selling options, represented as percentage * 10_000.
-    /// @dev i.e 20% -> 0.2 * 10_000 = 2_000.
-    uint256 immutable SELLER_COLLATERAL_RATIO;
-
-    /// @notice Required collateral ratios for buying options, represented as percentage * 10_000.
-    /// @dev i.e 10% -> 0.1 * 10_000 = 1_000.
-    uint256 immutable BUYER_COLLATERAL_RATIO;
+    bool internal constant IS_NOT_DEPOSIT = false;
+    bool internal constant IS_DEPOSIT = true;
 
-    /// @notice Basal cost (in bps of notional) to force exercise an out-of-range position.
-    int256 immutable FORCE_EXERCISE_COST;
-
-    // Targets a pool utilization (balance between buying and selling)
-    /// @notice Target pool utilization below which buying+selling is optimal, represented as percentage * 10_000.
-    /// @dev i.e 50% -> 0.5 * 10_000 = 5_000.
-    uint256 immutable TARGET_POOL_UTIL;
-
-    /// @notice Pool utilization above which selling is 100% collateral backed, represented as percentage * 10_000.
-    /// @dev i.e 90% -> 0.9 * 10_000 = 9_000.
-    uint256 immutable SATURATED_POOL_UTIL;
-
-    /// @notice Fee, in basis points, that is charged on the intrinsic value of ITM positions.
-    uint256 immutable ITM_SPREAD_FEE;
-
-    /// @notice The canonical Uniswap V4 Pool Manager address.
-    IPoolManager internal immutable POOL_MANAGER_V4;
+    /// @notice Transient storage slot for the utilization
+    bytes32 internal constant UTILIZATION_TRANSIENT_SLOT =
+        keccak256("panoptic.utilization.snapshot");
 
     /*//////////////////////////////////////////////////////////////
-                         POOL UTILIZATION DATA
+                           PANOPTIC POOL DATA
     //////////////////////////////////////////////////////////////*/
 
     /// @notice Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes.
-    uint128 internal s_poolAssets;
+    uint128 internal s_depositedAssets;
 
     /// @notice Amount of assets moved from the Panoptic Pool to the AMM.
-    uint128 internal s_inAMM;
+    uint128 internal s_assetsInAMM;
+
+    /// @notice Amount of shares credited to the protocol, includes credits and purchased option liquidity above the rehypothecation threshold.
+    uint256 internal s_creditedShares;
 
     /*//////////////////////////////////////////////////////////////
-                          INITIALIZATION STATE
+                           UNISWAP POOL DATA
     //////////////////////////////////////////////////////////////*/
 
-    /// @notice Boolean tracking whether this CollateralTracker has been initialized.
+    /// @notice Boolean which tracks whether this CollateralTracker has been initialized.
     bool internal s_initialized;
 
     /*//////////////////////////////////////////////////////////////
@@ -140,110 +146,157 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     //////////////////////////////////////////////////////////////*/
 
     // The parameters will be encoded at `_getImmutableArgsOffset()` in calldata as follows:
-    // abi.encodePacked(address panopticPool, bool underlyingIsCurrency0, address underlyingAsset, address currency0, address currency1, uint24 poolFee)
-    // bytes: 0                    20                 21                   41                   61                   81
-    //        |<----- 160 bits ---->|<---- 8 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 24 bits ---->|
-    //             panopticPool    underlyingIsCurrency0   underlyingAsset         currency0            currency1            poolFee
+    // abi.encodePacked(address panopticPool, bool underlyingIsToken0, address underlyingToken, address token0, address token1, uint24 poolFee)
+    // bytes: 0                    20                 21                   41                   61                   81                   101                 121
+    //        |<---- 160 bits ---->|<---- 8 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 24 bits ---->|
+    //             panopticPool     underlyingIsToken0    underlyingToken          token0               token1             riskEngine           POOL_MANAGER          poolFee
 
     /// @notice Retrieve the Panoptic Pool that this collateral token belongs to.
     /// @return The Panoptic Pool associated with this collateral token
-    function _panopticPool() internal pure returns (PanopticPool) {
+    function panopticPool() public pure returns (PanopticPool) {
         return PanopticPool(_getArgAddress(0));
     }
 
-    /// @notice Retrieve a boolean indicating whether the underlying asset is currency0 or currency1 in the Uniswap V4 pool.
-    /// @return underlyingIsCurrency0 True if the underlying asset is currency0, false if it is currency1
-    function _underlyingIsCurrency0() internal pure returns (bool underlyingIsCurrency0) {
+    /// @notice Retrieve a boolean indicating whether the underlying token is token0 or token1 in the Uniswap V3 pool.
+    /// @return _underlyingIsToken0 True if the underlying token is token0, false if it is token1
+    function underlyingIsToken0() public pure returns (bool _underlyingIsToken0) {
         uint256 offset = _getImmutableArgsOffset();
 
         assembly ("memory-safe") {
-            underlyingIsCurrency0 := shr(0xf8, calldataload(add(offset, 20)))
+            _underlyingIsToken0 := shr(0xf8, calldataload(add(offset, 20)))
         }
     }
 
-    /// @notice Retrieve the address of the underlying asset.
-    /// @return The address of the underlying asset
-    function _underlyingAsset() internal pure returns (address) {
+    /// @notice Retrieve the address of the underlying token.
+    /// @return The address of the underlying token
+    function underlyingToken() public pure returns (address) {
         return _getArgAddress(21);
     }
 
-    /// @notice Retrieve the address of currency0 in the Uniswap V4 pool.
-    /// @return The address of currency0 in the Uniswap V4 pool
-    function _currency0() internal pure returns (address) {
+    /// @notice Retrieve the address of token0 in the Uniswap V3 pool.
+    /// @return The address of token0 in the Uniswap V3 pool
+    function token0() public pure returns (address) {
         return _getArgAddress(41);
     }
 
-    /// @notice Retrieve the address of currency1 in the Uniswap V4 pool.
-    /// @return The address of currency1 in the Uniswap V4 pool
-    function _currency1() internal pure returns (address) {
+    /// @notice Retrieve the address of token1 in the Uniswap V3 pool.
+    /// @return The address of token1 in the Uniswap V3 pool
+    function token1() public pure returns (address) {
         return _getArgAddress(61);
     }
 
-    /// @notice Retrieve the fee of the Uniswap V4 pool.
-    /// @return poolFee The fee of the Uniswap V4 pool
-    function _poolFee() internal pure returns (uint24 poolFee) {
+    /// @notice Retrieve the RiskEngine associated with that CollateralTracker.
+    /// @return The RiskEngine instance associated with that CollateralTracker's uniswap pool
+    function riskEngine() public pure returns (IRiskEngine) {
+        return IRiskEngine(_getArgAddress(81));
+    }
+
+    /// @notice Retrieve the PoolManager associated with that CollateralTracker.
+    /// @dev stored as zero if not a Uniswap v4 pool
+    /// @return The PoolManager instance associated with that CollateralTracker's uniswap V4 pool
+    function poolManager() public pure returns (IPoolManager) {
+        return IPoolManager(_getArgAddress(101));
+    }
+
+    /// @notice Retrieve the fee of the Uniswap V3 pool.
+    /// @return _poolFee The fee of the Uniswap V3 pool
+    function poolFee() public pure returns (uint24 _poolFee) {
         uint256 offset = _getImmutableArgsOffset();
 
         assembly ("memory-safe") {
-            poolFee := shr(0xe8, calldataload(add(offset, 81)))
+            _poolFee := shr(0xe8, calldataload(add(offset, 121)))
         }
     }
 
+    /*//////////////////////////////////////////////////////////////
+                                STORAGE
+    //////////////////////////////////////////////////////////////*/
+
+    /**
+     * @notice How the Borrow Index Works
+     *
+     * The borrow index is a global accumulator that tracks how much $1 of debt
+     * grows over time with compound interest. It starts at 1e18 (representing 1.0)
+     * and increases continuously.
+     *
+     * Example:
+     * - User borrows 100 tokens when globalIndex = 1.0e18
+     * - Time passes, globalIndex grows to 1.2e18 (20% growth)
+     * - User now owes: 100 * (1.2e18 / 1.0e18) = 120 tokens
+     *
+     * Each user stores their "checkpoint" index from their last interaction,
+     * allowing efficient compound interest calculation without iteration.
+     */
+
+    /// @notice Global interest rate accumulator packed into a single 256-bit value
+    /// @dev Layout:
+    ///      - Left slot (106 bits): Accumulated unrealized interest that hasn't been distributed (max deposit is 2**104)
+    ///      - Next 38 bits: the rateAtTarget value in WAD (2**38 = 800% interest rate)
+    ///      - Next lowest 32 bits: Last interaction epoch (1 epoch = block.timestamp/4)
+    ///      - Lowest 80 bits: Global borrow index in WAD (starts at 1e18). 2**80 = 1.75 years at 800% interest
+    ///      The borrow index tracks the compound growth factor since protocol inception.
+    ///      A user's current debt = originalDebt * (currentBorrowIndex / userBorrowIndexSnapshot)
+    MarketState internal s_marketState;
+
+    /// @notice Tracks each user's borrowing state and last interaction checkpoint
+    /// @dev Packed layout:
+    ///      - Left slot (128 bits): Net borrows = netShorts - netLongs
+    ///        Represents the user's net borrowed amount in tokens
+    ///        Can be negative, in which case they purchased more options than they sold
+    ///      - Right slot (128 bits): User's borrow index snapshot
+    ///        The global borrow index value when this user last accrued interest
+    /// @dev Interest calculation: interestOwed = netBorrows * (currentIndex - userIndex) / userIndex
+    mapping(address account => LeftRightSigned interestState) internal s_interestState;
+
+    /*//////////////////////////////////////////////////////////////
+                            RISK PARAMETERS
+    //////////////////////////////////////////////////////////////*/
+
+    /// @notice The commission fee, in basis points, collected from PLPs at option mint.
+    /// @dev In Panoptic, options never expire, commissions are only paid when a new position is minted.
+    /// @dev We believe that this will eliminate the impact of the commission fee on the user's decision-making process when closing a position.
+    uint256 immutable COMMISSION_FEE;
+
     /*//////////////////////////////////////////////////////////////
                             ACCESS CONTROL
     //////////////////////////////////////////////////////////////*/
 
     /// @notice Reverts if the associated Panoptic Pool is not the caller.
     modifier onlyPanopticPool() {
-        if (msg.sender != address(_panopticPool())) revert Errors.NotPanopticPool();
+        _onlyPanopticPool();
         _;
     }
 
+    function _onlyPanopticPool() internal view {
+        if (msg.sender != address(panopticPool())) revert Errors.NotPanopticPool();
+    }
+
     /*//////////////////////////////////////////////////////////////
                   INITIALIZATION & PARAMETER SETTINGS
     //////////////////////////////////////////////////////////////*/
 
     /// @notice Set immutable parameters for the Collateral Tracker.
     /// @param _commissionFee The commission fee, in basis points, collected from PLPs at option mint
-    /// @param _sellerCollateralRatio Required collateral ratio for selling options, represented as percentage * 10_000
-    /// @param _buyerCollateralRatio Required collateral ratio for buying options, represented as percentage * 10_000
-    /// @param _forceExerciseCost Basal cost (in bps of notional) to force exercise an out-of-range position
-    /// @param _targetPoolUtilization Target pool utilization below which buying+selling is optimal, represented as percentage * 10_000
-    /// @param _saturatedPoolUtilization Pool utilization above which selling is 100% collateral backed, represented as percentage * 10_000
-    /// @param _ITMSpreadFee Fee, in basis points, that is charged on the intrinsic value of ITM positions
-    /// @param _manager The canonical Uniswap V4 pool manager
-    constructor(
-        uint256 _commissionFee,
-        uint256 _sellerCollateralRatio,
-        uint256 _buyerCollateralRatio,
-        int256 _forceExerciseCost,
-        uint256 _targetPoolUtilization,
-        uint256 _saturatedPoolUtilization,
-        uint256 _ITMSpreadFee,
-        IPoolManager _manager
-    ) {
+    constructor(uint256 _commissionFee) {
         COMMISSION_FEE = _commissionFee;
-        SELLER_COLLATERAL_RATIO = _sellerCollateralRatio;
-        BUYER_COLLATERAL_RATIO = _buyerCollateralRatio;
-        FORCE_EXERCISE_COST = _forceExerciseCost;
-        TARGET_POOL_UTIL = _targetPoolUtilization;
-        SATURATED_POOL_UTIL = _saturatedPoolUtilization;
-        ITM_SPREAD_FEE = _ITMSpreadFee;
-        POOL_MANAGER_V4 = _manager;
     }
 
-    /// @notice Initializes a new `CollateralTracker` instance with 1 virtual asset and 10^6 virtual shares.
+    /// @notice Initializes a new `CollateralTracker` instance with 1 virtual asset and 10^6 virtual shares. Can only be called once; reverts if already initialized.
     function initialize() external {
+        // fails if already initialized
         if (s_initialized) revert Errors.CollateralTokenAlreadyInitialized();
         s_initialized = true;
 
         // these virtual shares function as a multiplier for the capital requirement to manipulate the pool price
         // e.g. if the virtual shares are 10**6, then the capital requirement to manipulate the price to 10**12 is 10**18
-        totalSupply = 10 ** 6;
+        _internalSupply = 10 ** 6;
 
         // set total assets to 1
         // the initial share price is defined by 1/virtualShares
-        s_poolAssets = 1;
+        s_depositedAssets = 1;
+
+        // store the initial block and initialize the borrowIndex
+        s_marketState = MarketStateLibrary.storeMarketState(WAD, block.timestamp >> 2, 0, 0);
     }
 
     /*//////////////////////////////////////////////////////////////
@@ -251,46 +304,88 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     //////////////////////////////////////////////////////////////*/
 
     /// @notice Get information about the utilization of this collateral vault.
-    /// @return poolAssets Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes
-    /// @return insideAMM The underlying asset amount held in the AMM
-    /// @return currentPoolUtilization The pool utilization defined as`s_inAMM * 10_000 / totalAssets()`,
+    /// @return depositedAssets Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes
+    /// @return insideAMM The underlying token amount held in the AMM
+    /// @return creditedShares The amount of shares currently held as credit
+    /// @return currentPoolUtilization The pool utilization defined as`s_assetsInAMM * 10_000 / totalAssets()`,
     /// where totalAssets is the total tracked assets in the AMM and PanopticPool minus fees and donations to the Panoptic pool
     function getPoolData()
         external
         view
-        returns (uint256 poolAssets, uint256 insideAMM, uint256 currentPoolUtilization)
+        returns (
+            uint256 depositedAssets,
+            uint256 insideAMM,
+            uint256 creditedShares,
+            uint256 currentPoolUtilization
+        )
     {
-        poolAssets = s_poolAssets;
-        insideAMM = s_inAMM;
-        currentPoolUtilization = _poolUtilization();
+        depositedAssets = s_depositedAssets;
+        insideAMM = s_assetsInAMM;
+        creditedShares = s_creditedShares;
+        currentPoolUtilization = _poolUtilizationView();
+    }
+
+    /// @notice Returns the global borrow index that tracks compound interest growth
+    /// @dev The index starts at 1e18 and compounds continuously. Represents how much 1 unit of debt has grown since inception
+    /// @return The current global borrow index in WAD (18 decimals)
+    function borrowIndex() external view returns (uint80) {
+        return s_marketState.borrowIndex();
+    }
+
+    /// @notice Returns the last time at which interest rates were compounded.
+    /// @return The last time at which the interest rates were compounded
+    function lastInteractionTimestamp() external view returns (uint256) {
+        return s_marketState.marketEpoch() << 2;
+    }
+
+    /// @notice Returns the accumulated unrealized global interest
+    /// @return The total interest that has accumulated but not yet been distributed to lenders
+    function unrealizedGlobalInterest() external view returns (uint256) {
+        return s_marketState.unrealizedInterest();
+    }
+
+    /// @notice Returns rateAtTarget of the market
+    /// @return The rateAtTarget
+    function rateAtTarget() external view returns (uint256) {
+        return s_marketState.rateAtTarget();
     }
 
-    /// @notice Returns name of token composed of underlying asset symbol and pool data.
+    /// @notice Returns the borrowing state for a specific user
+    /// @dev Returns both the user's borrow index snapshot and their net borrowed amount
+    /// @return userBorrowIndex The borrow index when the user last accrued interest (used as the basis for interest calculation)
+    /// @return netBorrows The net borrowed amount for the user (positive = borrower, zero/negative = no interest owed)
+    function interestState(
+        address user
+    ) external view returns (int128 userBorrowIndex, int128 netBorrows) {
+        return (s_interestState[user].rightSlot(), s_interestState[user].leftSlot());
+    }
+
+    /// @notice Returns name of token composed of underlying token symbol and pool data.
     /// @return The name of the token
     function name() external view returns (string memory) {
         // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
         return
             InteractionHelper.computeName(
-                _currency0(),
-                _currency1(),
-                _underlyingIsCurrency0(),
-                _poolFee(),
+                token0(),
+                token1(),
+                underlyingIsToken0(),
+                poolFee(),
                 NAME_PREFIX
             );
     }
 
-    /// @notice Returns symbol as prefixed symbol of underlying asset.
+    /// @notice Returns symbol as prefixed symbol of underlying token.
     /// @return The symbol of the token
     function symbol() external view returns (string memory) {
         // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
-        return InteractionHelper.computeSymbol(_underlyingAsset(), TICKER_PREFIX);
+        return InteractionHelper.computeSymbol(underlyingToken(), TICKER_PREFIX);
     }
 
-    /// @notice Returns decimals of underlying asset (0 if not present).
+    /// @notice Returns decimals of underlying token (0 if not present).
     /// @return The decimals of the token
     function decimals() external view returns (uint8) {
         // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
-        return InteractionHelper.computeDecimals(_underlyingAsset());
+        return InteractionHelper.computeDecimals(underlyingToken());
     }
 
     /*//////////////////////////////////////////////////////////////
@@ -305,11 +400,12 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         address recipient,
         uint256 amount
     ) public override(ERC20Minimal) returns (bool) {
+        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);
         // make sure the caller does not have any open option positions
         // if they do: we don't want them sending panoptic pool shares to others
         // as this would reduce their amount of collateral against the opened positions
 
-        if (_panopticPool().numberOfLegs(msg.sender) != 0) revert Errors.PositionCountNotZero();
+        if (panopticPool().numberOfLegs(msg.sender) != 0) revert Errors.PositionCountNotZero();
 
         return ERC20Minimal.transfer(recipient, amount);
     }
@@ -324,11 +420,12 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         address to,
         uint256 amount
     ) public override(ERC20Minimal) returns (bool) {
+        _accrueInterest(from, IS_NOT_DEPOSIT);
         // make sure the sender does not have any open option positions
         // if they do: we don't want them sending panoptic pool shares to others
         // as this would reduce their amount of collateral against the opened positions
 
-        if (_panopticPool().numberOfLegs(from) != 0) revert Errors.PositionCountNotZero();
+        if (panopticPool().numberOfLegs(from) != 0) revert Errors.PositionCountNotZero();
 
         return ERC20Minimal.transferFrom(from, to, amount);
     }
@@ -341,55 +438,48 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param account The address of the account to transfer the underlying asset to/from
     /// @param delta The amount of the underlying asset to wrap/unwrap and transfer
     function _settleCurrencyDelta(address account, int256 delta) internal {
-        POOL_MANAGER_V4.unlock(abi.encode(account, delta, msg.value));
+        poolManager().unlock(abi.encode(account, delta, msg.value));
     }
 
     /// @notice Uniswap V4 unlock callback implementation.
     /// @dev Parameters are `(address account, int256 delta, uint256 valueOrigin)`.
     /// @dev Wraps/unwraps `delta` amount of the underlying asset and transfers to/from the Panoptic Pool.
-    /// @param data The encoded data containing the account and delta
+    /// @param data The encoded data containing the account, delta, and valueOrigin
     /// @return This function returns no data
     function unlockCallback(bytes calldata data) external returns (bytes memory) {
-        if (msg.sender != address(POOL_MANAGER_V4)) revert Errors.UnauthorizedUniswapCallback();
+        if (msg.sender != address(poolManager())) revert Errors.UnauthorizedUniswapCallback();
 
         (address account, int256 delta, uint256 valueOrigin) = abi.decode(
             data,
             (address, int256, uint256)
         );
 
-        address underlyingAsset = _underlyingAsset();
+        address underlyingAsset = underlyingToken();
         if (delta > 0) {
             if (Currency.wrap(underlyingAsset).isAddressZero()) {
-                POOL_MANAGER_V4.settle{value: uint256(delta)}();
+                poolManager().settle{value: uint256(delta)}();
 
+                // keep checked to prevent underflows
                 uint256 surplus = valueOrigin - uint256(delta);
                 if (surplus > 0) SafeTransferLib.safeTransferETH(account, surplus);
             } else {
-                POOL_MANAGER_V4.sync(Currency.wrap(underlyingAsset));
+                poolManager().sync(Currency.wrap(underlyingAsset));
                 SafeTransferLib.safeTransferFrom(
                     underlyingAsset,
                     account,
-                    address(POOL_MANAGER_V4),
+                    address(poolManager()),
                     uint256(delta)
                 );
-                POOL_MANAGER_V4.settle();
+                poolManager().settle();
             }
 
-            POOL_MANAGER_V4.mint(
-                address(_panopticPool()),
-                uint160(underlyingAsset),
-                uint256(delta)
-            );
+            poolManager().mint(address(panopticPool()), uint160(underlyingAsset), uint256(delta));
         } else if (delta < 0) {
             unchecked {
                 delta = -delta;
             }
-            POOL_MANAGER_V4.burn(
-                address(_panopticPool()),
-                uint160(underlyingAsset),
-                uint256(delta)
-            );
-            POOL_MANAGER_V4.take(Currency.wrap(underlyingAsset), account, uint256(delta));
+            poolManager().burn(address(panopticPool()), uint160(underlyingAsset), uint256(delta));
+            poolManager().take(Currency.wrap(underlyingAsset), account, uint256(delta));
         }
 
         return "";
@@ -399,10 +489,10 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
                      STANDARD ERC4626 INTERFACE
     //////////////////////////////////////////////////////////////*/
 
-    /// @notice Get the address of the underlying asset being managed (`address(0)` = native asset).
+    /// @notice Get the token contract address of the underlying asset being managed.
     /// @return assetTokenAddress The address of the underlying asset
     function asset() external pure returns (address assetTokenAddress) {
-        return _underlyingAsset();
+        return underlyingToken();
     }
 
     /// @notice Get the total amount of assets managed by the CollateralTracker vault.
@@ -412,7 +502,15 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @return The total amount of assets managed by the CollateralTracker vault
     function totalAssets() public view returns (uint256) {
         unchecked {
-            return uint256(s_poolAssets) + s_inAMM;
+            return uint256(s_depositedAssets) + s_assetsInAMM + s_marketState.unrealizedInterest();
+        }
+    }
+
+    /// @notice Returns the total supply of shares including credited shares
+    /// @return The total supply of shares (internal supply + credited shares)
+    function totalSupply() public view returns (uint256) {
+        unchecked {
+            return _internalSupply + s_creditedShares;
         }
     }
 
@@ -420,14 +518,21 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param assets The amount of assets to be deposited
     /// @return shares The amount of shares that can be minted
     function convertToShares(uint256 assets) public view returns (uint256 shares) {
-        return Math.mulDiv(assets, totalSupply, totalAssets());
+        return Math.mulDiv(assets, totalSupply(), totalAssets());
     }
 
     /// @notice Returns the amount of assets that can be redeemed for the given amount of shares.
     /// @param shares The amount of shares to be redeemed
     /// @return assets The amount of assets that can be redeemed
     function convertToAssets(uint256 shares) public view returns (uint256 assets) {
-        return Math.mulDiv(shares, totalAssets(), totalSupply);
+        return Math.mulDiv(shares, totalAssets(), totalSupply());
+    }
+
+    /// @notice Returns the amount of assets that can be redeem by the user.
+    /// @param owner The redeeming address
+    /// @return assets The amount of assets that can be redeemed
+    function assetsOf(address owner) external view returns (uint256 assets) {
+        return convertToAssets(balanceOf[owner]);
     }
 
     /// @notice Returns the maximum deposit amount.
@@ -440,47 +545,52 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param assets The amount of assets to be deposited
     /// @return shares The amount of shares that can be minted
     function previewDeposit(uint256 assets) public view returns (uint256 shares) {
-        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
-        unchecked {
-            shares = Math.mulDiv(
-                assets * (DECIMALS - COMMISSION_FEE),
-                totalSupply,
-                totalAssets() * DECIMALS
-            );
-        }
+        shares = Math.mulDiv(assets, totalSupply(), totalAssets());
     }
 
-    /// @notice Deposit underlying assets (assets) to the Panoptic pool from the LP and mint corresponding amount of shares.
-    /// @dev If depositing native currency (`asset() == address(0)`), non-EOA callers *must* accept empty calls with value up to the amount attached.
+    /// @notice Deposit underlying tokens (assets) to the Panoptic pool from the LP and mint corresponding amount of shares.
     /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
-    /// @dev An "MEV tax" is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
     /// @dev Shares are minted and sent to the LP (`receiver`).
     /// @param assets Amount of assets deposited
     /// @param receiver User to receive the shares
     /// @return shares The amount of Panoptic pool shares that were minted to the recipient
     function deposit(uint256 assets, address receiver) external payable returns (uint256 shares) {
+        _accrueInterest(msg.sender, IS_DEPOSIT);
         if (assets > type(uint104).max) revert Errors.DepositTooLarge();
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
 
         shares = previewDeposit(assets);
 
+        address _poolManager = address(poolManager());
+
+        if (_poolManager == address(0)) {
+            // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
+            // in return for the shares to be minted
+            SafeTransferLib.safeTransferFrom(
+                underlyingToken(),
+                msg.sender,
+                address(panopticPool()),
+                assets
+            );
+        }
+        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
         _mint(receiver, shares);
 
         // update tracked asset balance
-        s_poolAssets += uint128(assets);
-
-        // transfer assets from the user/the LP to the PanopticPool
-        // in return for the shares to be minted
-        _settleCurrencyDelta(msg.sender, int256(assets));
+        s_depositedAssets += uint128(assets);
 
+        if (_poolManager != address(0)) {
+            // transfer assets from the user/the LP to the PanopticPool
+            // in return for the shares to be minted
+            _settleCurrencyDelta(msg.sender, int256(assets));
+        }
         emit Deposit(msg.sender, receiver, assets, shares);
     }
 
     /// @notice Returns the maximum shares received for a deposit.
     /// @return maxShares The maximum amount of shares that can be minted
     function maxMint(address) external view returns (uint256 maxShares) {
-        unchecked {
-            return (convertToShares(type(uint104).max) * (DECIMALS - COMMISSION_FEE)) / DECIMALS;
-        }
+        return convertToShares(type(uint104).max);
     }
 
     /// @notice Returns the amount of assets that would be deposited to mint a given amount of shares.
@@ -489,39 +599,46 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     function previewMint(uint256 shares) public view returns (uint256 assets) {
         // round up depositing assets to avoid protocol loss
         // This prevents minting of shares where the assets provided is rounded down to zero
-        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
-        // finalAssets - convertedAssets = commissionRate * finalAssets
-        // finalAssets - commissionRate * finalAssets = convertedAssets
-        // finalAssets * (1 - commissionRate) = convertedAssets
-        // finalAssets = convertedAssets / (1 - commissionRate)
-        assets = Math.mulDivRoundingUp(
-            shares * DECIMALS,
-            totalAssets(),
-            totalSupply * (DECIMALS - COMMISSION_FEE)
-        );
+        assets = Math.mulDivRoundingUp(shares, totalAssets(), totalSupply());
     }
 
     /// @notice Deposit required amount of assets to receive specified amount of shares.
-    /// @dev If depositing native currency (`asset() == address(0)`), non-EOA callers *must* accept empty calls with value up to the amount attached.
     /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
-    /// @dev An "MEV tax" is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
     /// @dev Shares are minted and sent to the LP (`receiver`).
     /// @param shares Amount of shares to be minted
     /// @param receiver User to receive the shares
     /// @return assets The amount of assets deposited to mint the desired amount of shares
     function mint(uint256 shares, address receiver) external payable returns (uint256 assets) {
+        _accrueInterest(msg.sender, IS_DEPOSIT);
         assets = previewMint(shares);
 
         if (assets > type(uint104).max) revert Errors.DepositTooLarge();
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
+
+        address _poolManager = address(poolManager());
+
+        if (_poolManager == address(0)) {
+            // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
+            // in return for the shares to be minted
+            SafeTransferLib.safeTransferFrom(
+                underlyingToken(),
+                msg.sender,
+                address(panopticPool()),
+                assets
+            );
+        }
 
+        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
         _mint(receiver, shares);
 
         // update tracked asset balance
-        s_poolAssets += uint128(assets);
+        s_depositedAssets += uint128(assets);
 
-        // transfer assets from the user/the LP to the PanopticPool
-        // in return for the shares to be minted
-        _settleCurrencyDelta(msg.sender, int256(assets));
+        if (_poolManager != address(0)) {
+            // transfer assets from the user/the LP to the PanopticPool
+            // in return for the shares to be minted
+            _settleCurrencyDelta(msg.sender, int256(assets));
+        }
 
         emit Deposit(msg.sender, receiver, assets, shares);
     }
@@ -532,11 +649,25 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param owner The address being withdrawn for
     /// @return maxAssets The maximum amount of assets that can be withdrawn
     function maxWithdraw(address owner) public view returns (uint256 maxAssets) {
-        uint256 poolAssets = s_poolAssets;
+        uint256 depositedAssets = s_depositedAssets;
+        unchecked {
+            uint256 available = depositedAssets > 0 ? depositedAssets - 1 : 0;
+            uint256 balance = convertToAssets(balanceOf[owner]);
+            return panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
+        }
+    }
+
+    /// @notice Returns The maximum amount of assets that can be withdrawn for a given user with open positions.
+    /// If the user has any open positions, the max withdrawable balance is zero.
+    /// @dev Calculated from the balance of the user; limited by the assets the pool has available.
+    /// @param owner The address being withdrawn for
+    /// @return maxAssets The maximum amount of assets that can be withdrawn
+    function _maxWithdrawWithPositions(address owner) internal view returns (uint256 maxAssets) {
+        uint256 depositedAssets = s_depositedAssets;
         unchecked {
-            uint256 available = poolAssets > 0 ? poolAssets - 1 : 0;
+            uint256 available = depositedAssets > 0 ? depositedAssets - 1 : 0;
             uint256 balance = convertToAssets(balanceOf[owner]);
-            return _panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
+            return Math.min(available, balance);
         }
     }
 
@@ -544,7 +675,7 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param assets The amount of assets to be withdrawn
     /// @return shares The amount of shares that would be burned
     function previewWithdraw(uint256 assets) public view returns (uint256 shares) {
-        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
+        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply() is non-zero.
 
         return Math.mulDivRoundingUp(assets, supply, totalAssets());
     }
@@ -561,7 +692,9 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         address receiver,
         address owner
     ) external returns (uint256 shares) {
+        _accrueInterest(owner, IS_NOT_DEPOSIT);
         if (assets > maxWithdraw(owner)) revert Errors.ExceedsMaximumRedemption();
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
 
         shares = previewWithdraw(assets);
 
@@ -572,16 +705,28 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares; // Saves gas for unlimited approvals.
         }
 
+        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
         _burn(owner, shares);
 
         // update tracked asset balance
-        unchecked {
-            s_poolAssets -= uint128(assets);
-        }
-
-        // transfer assets from the PanopticPool to the LP
-        unchecked {
-            _settleCurrencyDelta(receiver, -int256(assets));
+        // keep checked to prevent underflows
+        s_depositedAssets -= uint128(assets);
+
+        address _poolManager = address(poolManager());
+
+        if (_poolManager == address(0)) {
+            // transfer assets (underlying token funds) from the PanopticPool to the LP
+            SafeTransferLib.safeTransferFrom(
+                underlyingToken(),
+                address(panopticPool()),
+                receiver,
+                assets
+            );
+        } else {
+            // transfer assets from the PanopticPool to the LP
+            unchecked {
+                _settleCurrencyDelta(receiver, -int256(assets));
+            }
         }
 
         emit Withdraw(msg.sender, receiver, owner, assets, shares);
@@ -594,8 +739,8 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param receiver User to receive the assets
     /// @param owner User to burn the shares from
     /// @param positionIdList The list of all option positions held by `owner`
-    /// @return shares The amount of shares burned to withdraw the desired amount of assets
     /// @param usePremiaAsCollateral Whether to compute accumulated premia for all legs held by the user for collateral (true), or just owed premia for long legs (false)
+    /// @return shares The amount of shares burned to withdraw the desired amount of assets
     function withdraw(
         uint256 assets,
         address receiver,
@@ -603,32 +748,43 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         TokenId[] calldata positionIdList,
         bool usePremiaAsCollateral
     ) external returns (uint256 shares) {
+        _accrueInterest(owner, IS_NOT_DEPOSIT);
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
+        if (assets > _maxWithdrawWithPositions(owner)) revert Errors.ExceedsMaximumRedemption();
+
         shares = previewWithdraw(assets);
 
         // check/update allowance for approved withdraw
         if (msg.sender != owner) {
             uint256 allowed = allowance[owner][msg.sender];
-
             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares; // Saves gas for unlimited approvals.
         }
 
+        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
         _burn(owner, shares);
 
         // update tracked asset balance
-        s_poolAssets -= uint128(assets);
+        s_depositedAssets -= uint128(assets);
 
         // reverts if account is not solvent/eligible to withdraw
-        _panopticPool().validateCollateralWithdrawable(
-            owner,
-            positionIdList,
-            usePremiaAsCollateral
-        );
+        panopticPool().validateCollateralWithdrawable(owner, positionIdList, usePremiaAsCollateral);
 
-        // transfer assets from the PanopticPool to the LP
-        unchecked {
-            _settleCurrencyDelta(receiver, -int256(assets));
-        }
+        address _poolManager = address(poolManager());
 
+        if (_poolManager == address(0)) {
+            // transfer assets (underlying token funds) from the PanopticPool to the LP
+            SafeTransferLib.safeTransferFrom(
+                underlyingToken(),
+                address(panopticPool()),
+                receiver,
+                assets
+            );
+        } else {
+            // transfer assets from the PanopticPool to the LP
+            unchecked {
+                _settleCurrencyDelta(receiver, -int256(assets));
+            }
+        }
         emit Withdraw(msg.sender, receiver, owner, assets, shares);
     }
 
@@ -637,11 +793,11 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
     /// @param owner The redeeming address
     /// @return maxShares The maximum amount of shares that can be redeemed by `owner`
     function maxRedeem(address owner) public view returns (uint256 maxShares) {
-        uint256 poolAssets = s_poolAssets;
+        uint256 depositedAssets = s_depositedAssets;
         unchecked {
-            uint256 available = convertToShares(poolAssets > 0 ? poolAssets - 1 : 0);
+            uint256 available = convertToShares(depositedAssets > 0 ? depositedAssets - 1 : 0);
             uint256 balance = balanceOf[owner];
-            return _panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
+            return panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
         }
     }
 
@@ -663,6 +819,7 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         address receiver,
         address owner
     ) external returns (uint256 assets) {
+        _accrueInterest(owner, IS_NOT_DEPOSIT);
         if (shares > maxRedeem(owner)) revert Errors.ExceedsMaximumRedemption();
 
         // check/update allowance for approved redeem
@@ -673,234 +830,380 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         }
 
         assets = previewRedeem(shares);
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
 
+        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
         _burn(owner, shares);
 
         // update tracked asset balance
-        unchecked {
-            s_poolAssets -= uint128(assets);
-        }
-
-        // transfer assets from the PanopticPool to the LP
-        unchecked {
-            _settleCurrencyDelta(receiver, -int256(assets));
+        // keep checked to avoid underflows
+        s_depositedAssets -= uint128(assets);
+        address _poolManager = address(poolManager());
+
+        if (_poolManager == address(0)) {
+            // transfer assets (underlying token funds) from the PanopticPool to the LP
+            SafeTransferLib.safeTransferFrom(
+                underlyingToken(),
+                address(panopticPool()),
+                receiver,
+                assets
+            );
+        } else {
+            // transfer assets from the PanopticPool to the LP
+            unchecked {
+                _settleCurrencyDelta(receiver, -int256(assets));
+            }
         }
-
         emit Withdraw(msg.sender, receiver, owner, assets, shares);
     }
 
-    /*//////////////////////////////////////////////////////////////
-                            ACCOUNTING LOGIC
-    //////////////////////////////////////////////////////////////*/
+    /// @notice Donate exact shares to all shareholders.
+    /// @dev Can only be used when the user has no open positions
+    /// @param shares Amount of shares to be donated
+    function donate(uint256 shares) external {
+        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);
 
-    /// @notice Get the cost of exercising an option. Used during a forced exercise.
-    /// @notice This one computes the cost of calling the forceExercise function on a position:
-    /// - The forceExercisor will have to *pay* the exercisee because their position will be closed "against their will"
-    /// - The cost must be larger when the position is close to being in-range, and should be minimal when it is far from being in range. eg. Exercising a (1000, 1050)
-    ///   position will cost more if the price is 999 than if it is 100
-    /// - The cost is an exponentially decaying function of the distance between the position's strike and the current price
-    /// - The cost decreases by a factor of 2 for every "position's width"
-    /// - Note that the cost is the largest among all active legs, not the sum
-    /// @notice Example exercise cost progression:
-    /// - 10% if the position is liquidated when the price is between 950 and 1000, or if it is between 1050 and 1100
-    /// - 5% if the price is between 900 and 950 or (1100, 1150)
-    /// - 2.5% if between (850, 900) or (1150, 1200)
-    /// @param currentTick The current price tick
-    /// @param oracleTick The price oracle tick
-    /// @param positionId The position to be exercised
-    /// @param positionSize The size of the position to be exercised
-    /// @param longAmounts The amount of longs in the position
-    /// @return exerciseFees The fees for exercising the option position
-    function exerciseCost(
-        int24 currentTick,
-        int24 oracleTick,
-        TokenId positionId,
-        uint128 positionSize,
-        LeftRightSigned longAmounts
-    ) external view returns (LeftRightSigned exerciseFees) {
-        // find the leg furthest to the strike price `currentTick`; this will have the lowest exercise cost
-        // we don't need the leg information itself, really just "the number of half ranges" from the strike price:
-        uint256 maxNumRangesFromStrike = 1; // technically "maxNum(Half)RangesFromStrike" but the name is long
+        if (shares > maxRedeem(msg.sender)) revert Errors.ExceedsMaximumRedemption();
 
-        unchecked {
-            for (uint256 leg = 0; leg < positionId.countLegs(); ++leg) {
-                // short legs are not counted - exercise is intended to be based on long legs
-                if (positionId.isLong(leg) == 0) continue;
-
-                {
-                    int24 range = int24(
-                        int256(
-                            Math.unsafeDivRoundingUp(
-                                uint24(positionId.width(leg) * positionId.tickSpacing()),
-                                2
-                            )
-                        )
-                    );
-                    maxNumRangesFromStrike = Math.max(
-                        maxNumRangesFromStrike,
-                        uint256(Math.abs(currentTick - positionId.strike(leg)) / range)
-                    );
-                }
+        uint256 assets = previewRedeem(shares);
+        if (assets == 0) revert Errors.BelowMinimumRedemption();
 
-                uint256 currentValue0;
-                uint256 currentValue1;
-                uint256 oracleValue0;
-                uint256 oracleValue1;
+        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
+        _burn(msg.sender, shares);
 
-                {
-                    LiquidityChunk liquidityChunk = PanopticMath.getLiquidityChunk(
-                        positionId,
-                        leg,
-                        positionSize
-                    );
+        emit Donate(msg.sender, shares);
+    }
 
-                    (currentValue0, currentValue1) = Math.getAmountsForLiquidity(
-                        currentTick,
-                        liquidityChunk
-                    );
+    /// @notice Accrues protocol-wide interest for the calling user
+    /// @dev Updates global interest state and settles any outstanding interest for msg.sender
+    function accrueInterest() external {
+        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);
+    }
 
-                    (oracleValue0, oracleValue1) = Math.getAmountsForLiquidity(
-                        oracleTick,
-                        liquidityChunk
-                    );
+    /// @notice Accrues protocol-wide interest and settles a specific user's interest.
+    /// @dev This function should be called before any user action that affects their borrow balance.
+    /// @param owner the account which calls accrue interest
+    function _accrueInterest(address owner, bool isDeposit) internal {
+        uint128 _assetsInAMM = s_assetsInAMM;
+        (
+            uint128 currentBorrowIndex,
+            uint128 _unrealizedGlobalInterest,
+            uint256 currentEpoch
+        ) = _calculateCurrentInterestState(_assetsInAMM, _updateInterestRate());
+
+        // USER
+        LeftRightSigned userState = s_interestState[owner];
+        int128 netBorrows = userState.leftSlot();
+        int128 userBorrowIndex = int128(currentBorrowIndex);
+        if (netBorrows > 0) {
+            uint128 userInterestOwed = _getUserInterest(userState, currentBorrowIndex);
+            if (userInterestOwed != 0) {
+                uint256 _totalAssets;
+                unchecked {
+                    _totalAssets = s_depositedAssets + _assetsInAMM + _unrealizedGlobalInterest;
                 }
 
-                // reverse any deltas between the current and oracle prices for the chunk the exercisee had to mint in Uniswap
-                // the outcome of current price crossing a long chunk will always be less favorable than the status quo, i.e.,
-                // if the current price is moved downward such that some part of the chunk is between the current and market prices,
-                // the chunk composition will swap currency1 for currency0 at a price (currency0/currency1) more favorable than market (currency1/currency0),
-                // forcing the exercisee to provide more value in currency0 than they would have provided in currency1 at market, and vice versa.
-                // (the excess value provided by the exercisee could then be captured in a return swap across their newly added liquidity)
-                exerciseFees = exerciseFees.sub(
-                    LeftRightSigned
-                        .wrap(0)
-                        .toRightSlot(int128(uint128(currentValue0)) - int128(uint128(oracleValue0)))
-                        .toLeftSlot(int128(uint128(currentValue1)) - int128(uint128(oracleValue1)))
+                uint256 shares = Math.mulDivRoundingUp(
+                    userInterestOwed,
+                    totalSupply(),
+                    _totalAssets
                 );
-            }
 
-            // NOTE: we HAVE to start with a negative number as the base exercise cost because when shifting a negative number right by n bits,
-            // the result is rounded DOWN and NOT toward zero
-            // this divergence is observed when n (the number of half ranges) is > 10 (ensuring the floor is not zero, but -1 = 1bps at that point)
-            // subtract 1 from max half ranges from strike so fee starts at FORCE_EXERCISE_COST when moving OTM
-            int256 fee = (FORCE_EXERCISE_COST >> (maxNumRangesFromStrike - 1)); // exponential decay of fee based on number of half ranges away from the price
+                uint128 burntInterestValue = userInterestOwed;
+
+                address _owner = owner;
+                uint256 userBalance = balanceOf[_owner];
+                if (shares > userBalance) {
+                    if (!isDeposit) {
+                        // update the accrual of interest paid
+                        burntInterestValue = Math
+                            .mulDiv(userBalance, _totalAssets, totalSupply())
+                            .toUint128();
+
+                        emit InsolvencyPenaltyApplied(
+                            owner,
+                            userInterestOwed,
+                            burntInterestValue,
+                            userBalance
+                        );
+
+                        /// Insolvent case: Pay what you can
+                        _burn(_owner, userBalance);
+
+                        /// @dev DO NOT update index. By keeping the user's old baseIndex, their debt continues to compound correctly from the original point in time.
+                        userBorrowIndex = userState.rightSlot();
+                    } else {
+                        // set interest paid to zero
+                        burntInterestValue = 0;
+
+                        // we effectively **did not settle** this user:
+                        // we keep their old baseIndex so future interest is computed correctly.
+                        userBorrowIndex = userState.rightSlot();
+                    }
+                } else {
+                    // Solvent case: Pay in full.
+                    _burn(_owner, shares);
+                }
 
-            // store the exercise fees in the exerciseFees variable
-            exerciseFees = exerciseFees
-                .toRightSlot(int128((longAmounts.rightSlot() * fee) / DECIMALS_128))
-                .toLeftSlot(int128((longAmounts.leftSlot() * fee) / DECIMALS_128));
+                // Due to repeated rounding up when:
+                //  - compounding the global borrow index (multiplicative propagation of rounding error), and
+                //  - converting a user's interest into shares,
+                // burntInterestValue can exceed _unrealizedGlobalInterest by a few wei (because that accumulator calculates interest additively).
+                // In that case, treat all remaining unrealized interest as consumed
+                // and clamp the bucket to zero; otherwise subtract normally.
+                if (burntInterestValue > _unrealizedGlobalInterest) {
+                    _unrealizedGlobalInterest = 0;
+                } else {
+                    unchecked {
+                        // can never underflow because burntInterestValue <= _unrealizedGlobalInterest
+                        _unrealizedGlobalInterest = _unrealizedGlobalInterest - burntInterestValue;
+                    }
+                }
+            }
         }
+
+        s_interestState[owner] = LeftRightSigned
+            .wrap(0)
+            .addToRightSlot(userBorrowIndex)
+            .addToLeftSlot(netBorrows);
+
+        s_marketState = MarketStateLibrary.storeMarketState(
+            currentBorrowIndex,
+            currentEpoch,
+            s_marketState.rateAtTarget(),
+            _unrealizedGlobalInterest
+        );
     }
 
-    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
-    /// @return poolUtilization The pool utilization in basis points
-    function _poolUtilization() internal view returns (uint256 poolUtilization) {
+    /// @notice Calculates the current interest state without modifying storage
+    /// @dev Simulates interest accrual from last interaction to current epoch
+    /// @param _assetsInAMM Amount of assets currently deployed in AMM positions
+    /// @param interestRateSnapshot The current interest rate to evaluate at
+    /// @return currentBorrowIndex Updated global borrow index after simulated accrual
+    /// @return _unrealizedGlobalInterest Total unrealized interest including new accrual
+    /// @return currentEpoch Current epoch = block timestamp / 4
+    function _calculateCurrentInterestState(
+        uint128 _assetsInAMM,
+        uint128 interestRateSnapshot
+    )
+        internal
+        view
+        returns (
+            uint128 currentBorrowIndex,
+            uint128 _unrealizedGlobalInterest,
+            uint256 currentEpoch
+        )
+    {
+        MarketState accumulator = s_marketState;
+
+        currentEpoch = block.timestamp >> 2;
+        uint256 previousEpoch = accumulator.marketEpoch();
+        uint128 deltaTime;
         unchecked {
-            return (s_inAMM * DECIMALS) / totalAssets();
+            deltaTime = uint32(currentEpoch - previousEpoch) << 2;
         }
-    }
+        currentBorrowIndex = accumulator.borrowIndex();
+        _unrealizedGlobalInterest = accumulator.unrealizedInterest();
+        if (deltaTime > 0) {
+            // Calculate interest growth
+            uint128 rawInterest = (Math.wTaylorCompounded(interestRateSnapshot, uint128(deltaTime)))
+                .toUint128();
+            // Calculate interest owed on borrowed amount
+
+            uint128 interestOwed = Math.mulDivWadRoundingUp(_assetsInAMM, rawInterest).toUint128();
 
-    /// @notice Get the base collateral requirement for a short leg at a given pool utilization.
-    /// @dev This is computed at the time the position is minted.
-    /// @param utilization The pool utilization of this collateral vault at the time the position is minted
-    /// @return sellCollateralRatio The sell collateral ratio at `utilization`
-    function _sellCollateralRatio(
-        int256 utilization
-    ) internal view returns (uint256 sellCollateralRatio) {
-        // the sell ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
-        //   (x0,y0) = (targetPoolUtilization,min_sell_ratio) and
-        //   (x1,y1) = (saturatedPoolUtilization,max_sell_ratio)
-        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
-        /*
-            SELL
-            COLLATERAL
-            RATIO
-                          ^
-                          |                  max ratio = 100%
-                   100% - |                _------
-                          |             _-¯
-                          |          _-¯
-                    20% - |---------¯
-                          |         .       . .
-                          +---------+-------+-+--->   POOL_
-                                   50%    90% 100%     UTILIZATION
-        */
-
-        uint256 min_sell_ratio = SELLER_COLLATERAL_RATIO;
-        /// if utilization is less than zero, this is the calculation for a strangle, which gets 2x the capital efficiency at low pool utilization
-        if (utilization < 0) {
+            // keep checked to prevent overflows
+            _unrealizedGlobalInterest += interestOwed;
+
+            // Update borrow index
             unchecked {
-                min_sell_ratio /= 2;
-                utilization = -utilization;
+                uint128 _borrowIndex = (WAD + rawInterest).toUint128();
+                currentBorrowIndex = Math
+                    .mulDivWadRoundingUp(currentBorrowIndex, _borrowIndex)
+                    .toUint128();
             }
         }
+    }
+
+    /*//////////////////////////////////////////////////////////////
+                  ADAPTIVE INTEREST RATE MODEL
+    //////////////////////////////////////////////////////////////*/
+
+    function _interestRateView(uint256 utilization) internal view returns (uint128) {
+        uint128 avgRate = riskEngine().interestRate(utilization, s_marketState);
+        return avgRate;
+    }
+
+    /// @notice Returns the current interest rate per second based on pool utilization
+    /// @return The current interest rate per second in WAD (18 decimal precision)
+    function interestRate() public view returns (uint128) {
+        uint128 avgRate = riskEngine().interestRate(_poolUtilizationWadView(), s_marketState);
+        return avgRate;
+    }
+
+    /// @notice Returns the interest rate per second based on pool utilization
+    /// @dev uses the maximum utilization during this transaction, users to prevent flash deposits from lowering the interest rate
+    /// @return The interest rate per second in 18 decimal precision
+    function _updateInterestRate() internal returns (uint128) {
+        (uint128 avgRate, uint256 endRateAtTarget) = riskEngine().updateInterestRate(
+            _poolUtilizationWad(),
+            s_marketState
+        );
+        s_marketState = s_marketState.updateRateAtTarget(uint40(endRateAtTarget));
+        return avgRate;
+    }
+
+    /// @notice Calculates interest owed by a user based on their borrow state
+    /// @dev Uses the difference between current and user's last borrow index to compute compound interest
+    /// @param userState Packed state containing user's net borrows (left slot) and last borrow index (right slot)
+    /// @param currentBorrowIndex The current global borrow index
+    /// @return interestOwed Amount of interest the user owes, returns 0 if user is a lender or indices match
+    function _getUserInterest(
+        LeftRightSigned userState,
+        uint256 currentBorrowIndex
+    ) internal pure returns (uint128 interestOwed) {
+        int128 netBorrows = userState.leftSlot();
+        uint128 userBorrowIndex = uint128(userState.rightSlot());
+        if (netBorrows <= 0 || userBorrowIndex == 0 || currentBorrowIndex == userBorrowIndex) {
+            return 0;
+        }
+        // keep checked to catch currentBorrowIndex < userBorrowIndex
+        interestOwed = Math
+            .mulDivRoundingUp(
+                uint128(netBorrows),
+                currentBorrowIndex - userBorrowIndex,
+                userBorrowIndex
+            )
+            .toUint128();
+    }
+
+    /// @notice Returns the current interest owed by a specific user in assets
+    /// @param owner Address of the user to check
+    /// @return The amount of interest currently owed by the user in assets
+    function owedInterest(address owner) external view returns (uint128) {
+        return _owedInterest(owner);
+    }
 
-        // return the basal sell ratio if pool utilization is lower than target
-        if (uint256(utilization) < TARGET_POOL_UTIL) {
-            return min_sell_ratio;
+    /// @notice Returns the assets and interest owed for a specific user
+    /// @param owner Address of the user to check
+    /// @return The amount of assets owned by the user (in token units)
+    /// @return The amount of interest currently owed by the user (in token units)
+    function assetsAndInterest(address owner) external view returns (uint256, uint256) {
+        return (convertToAssets(balanceOf[owner]), _owedInterest(owner));
+    }
+
+    /// @notice Internal function to calculate interest owed by a user
+    /// @dev Retrieves user state and current borrow index from storage
+    /// @param owner Address of the user to check
+    /// @return Amount of interest owed based on last compounded index
+    function _owedInterest(address owner) internal view returns (uint128) {
+        LeftRightSigned userState = s_interestState[owner];
+        (uint128 currentBorrowIndex, , ) = _calculateCurrentInterestState(
+            s_assetsInAMM,
+            _interestRateView(_poolUtilizationWadView())
+        );
+        return _getUserInterest(userState, currentBorrowIndex);
+    }
+
+    /// @notice Calculates the current borrow index including uncompounded time
+    /// @dev Simulates interest accrual up to the current block epoch
+    /// @return The borrow index as if interest was compounded at current epoch
+    function _calculateCurrentBorrowIndex() internal view returns (uint256) {
+        (uint128 currentBorrowIndex, , ) = _calculateCurrentInterestState(
+            s_assetsInAMM,
+            _interestRateView(_poolUtilizationWadView())
+        );
+        return currentBorrowIndex;
+    }
+
+    /// @notice Previews the interest that would be owed if compounded now
+    /// @dev Simulates interest accrual without modifying state
+    /// @param owner Address of the user to preview interest for
+    /// @return The amount of interest that would be owed if accrued at current epoch
+    function previewOwedInterest(address owner) external view returns (uint128) {
+        uint256 simulatedBorrowIndex = _calculateCurrentBorrowIndex();
+        LeftRightSigned userState = s_interestState[owner];
+        return _getUserInterest(userState, simulatedBorrowIndex);
+    }
+
+    /*//////////////////////////////////////////////////////////////
+                            ACCOUNTING LOGIC
+    //////////////////////////////////////////////////////////////*/
+
+    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
+    /// @dev calling this function will also store the utilization in the UTILIZATION_TRANSIENT_SLOT as DECIMALS
+    /// if the current one is higher than the one already stored. This ensures that flash deposits can't lower the utilization for a single tx
+    /// @return poolUtilization The pool utilization in basis points
+    function _poolUtilization() internal returns (uint256 poolUtilization) {
+        uint256 storedUtilization;
+        bytes32 slot = UTILIZATION_TRANSIENT_SLOT;
+        assembly {
+            storedUtilization := tload(slot)
         }
 
-        // return 100% collateral ratio if utilization is above saturated pool utilization
-        if (uint256(utilization) > SATURATED_POOL_UTIL) {
-            return DECIMALS;
+        poolUtilization = _poolUtilizationView();
+
+        if (storedUtilization > poolUtilization) {
+            return storedUtilization;
+        } else {
+            assembly {
+                tstore(slot, poolUtilization)
+            }
+            return poolUtilization;
         }
+    }
 
+    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
+    /// @return poolUtilization The pool utilization in basis points
+    function _poolUtilizationView() internal view returns (uint256 poolUtilization) {
         unchecked {
             return
-                min_sell_ratio +
-                ((DECIMALS - min_sell_ratio) * (uint256(utilization) - TARGET_POOL_UTIL)) /
-                (SATURATED_POOL_UTIL - TARGET_POOL_UTIL);
+                poolUtilization = Math.mulDivRoundingUp(
+                    uint256(s_assetsInAMM) + uint256(s_marketState.unrealizedInterest()),
+                    DECIMALS,
+                    totalAssets()
+                );
         }
     }
 
-    /// @notice Get the base collateral requirement for a long leg at a given pool utilization.
-    /// @dev This is computed at the time the position is minted.
-    /// @param utilization The pool utilization of this collateral vault at the time the position is minted
-    /// @return buyCollateralRatio The buy collateral ratio at `utilization`
-    function _buyCollateralRatio(
-        uint16 utilization
-    ) internal view returns (uint256 buyCollateralRatio) {
-        // linear from BUY to BUY/2 between 50% and 90%
-        // the buy ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
-        //   (x0,y0) = (targetPoolUtilization,buyCollateralRatio) and
-        //   (x1,y1) = (saturatedPoolUtilization,buyCollateralRatio / 2)
-        // note that y1<y0 so the slope is negative:
-        // aka the buy ratio starts high and drops to a lower value with increased utilization; the sell ratio does the opposite (slope is positive)
-        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
-        // but since a<0, we rewrite as:
-        // y = a' * (x0 - x) + y0, where a' = (y0 - y1) / (x1 - x0)
-
-        /*
-          BUY
-          COLLATERAL
-          RATIO
-                 ^
-                 |   buy_ratio = 10%
-           10% - |----------__       min_ratio = 5%
-           5%  - | . . . . .  ¯¯¯--______
-                 |         .       . .
-                 +---------+-------+-+--->   POOL_
-                          50%    90% 100%      UTILIZATION
-         */
-
-        // return the basal buy ratio if pool utilization is lower than target
-        if (utilization < TARGET_POOL_UTIL) {
-            return BUYER_COLLATERAL_RATIO;
+    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
+    /// @dev calling this function will also store the utilization in the UTILIZATION_TRANSIENT_SLOT as DECIMALS
+    /// if the current one is higher than the one already stored. This ensures that flash deposits can't lower the utilization for a single tx
+    /// @return poolUtilization The pool utilization in basis points
+    function _poolUtilizationWad() internal returns (uint256) {
+        uint256 storedUtilization;
+        bytes32 slot = UTILIZATION_TRANSIENT_SLOT;
+        assembly {
+            storedUtilization := tload(slot)
         }
 
-        // return the basal ratio divided by 2 if pool utilization is above saturated pool utilization
-        /// this incentivizes option buying, which returns funds to the Panoptic pool
-        if (utilization > SATURATED_POOL_UTIL) {
-            unchecked {
-                return BUYER_COLLATERAL_RATIO / 2;
+        unchecked {
+            // convert to WAD
+            storedUtilization = (storedUtilization * WAD) / DECIMALS;
+        }
+        uint256 poolUtilization = _poolUtilizationWadView();
+
+        if (storedUtilization > poolUtilization) {
+            return storedUtilization;
+        } else {
+            // store the utilization as DECIMALS
+            assembly {
+                tstore(slot, div(mul(poolUtilization, DECIMALS), WAD))
             }
+            return poolUtilization;
         }
+    }
 
+    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
+    /// @return poolUtilization The pool utilization in WAD
+    function _poolUtilizationWadView() internal view returns (uint256 poolUtilization) {
         unchecked {
             return
-                (BUYER_COLLATERAL_RATIO +
-                    (BUYER_COLLATERAL_RATIO * (SATURATED_POOL_UTIL - utilization)) /
-                    (SATURATED_POOL_UTIL - TARGET_POOL_UTIL)) / 2; // do the division by 2 at the end after all addition and multiplication; b/c y1 = buyCollateralRatio / 2
+                Math.mulDivRoundingUp(
+                    uint256(s_assetsInAMM) + uint256(s_marketState.unrealizedInterest()),
+                    WAD,
+                    totalAssets()
+                );
         }
     }
 
@@ -910,17 +1213,45 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
 
     /// @notice Increase the share balance of a user by `2^248 - 1` without updating the total supply.
     /// @dev This is controlled by the Panoptic Pool - not individual users.
+    /// @dev When the user owes more interest than their balance, we reduce the delegation amount
+    /// by their entire balance. This accounts for the fact that _accrueInterest will consume
+    /// their real shares for interest payment, preventing the delegated virtual shares from
+    /// being incorrectly used to pay interest obligations.
     /// @param delegatee The account to increase the balance of
     function delegate(address delegatee) external onlyPanopticPool {
-        balanceOf[delegatee] += type(uint248).max;
+        // Round up to match _accrueInterest's share calculation
+        uint256 interestShares = previewWithdraw(_owedInterest(delegatee));
+        uint256 balance = balanceOf[delegatee];
+
+        // If user owes more interest than they have, their entire balance will be consumed
+        // paying interest. Reduce delegation by this amount so virtual shares aren't used
+        // for interest payment.
+        uint256 balanceConsumedByInterest = interestShares > balance ? balance : 0;
+
+        // keep checked to catch overflows
+        balanceOf[delegatee] += type(uint248).max - balanceConsumedByInterest;
     }
 
     /// @notice Decrease the share balance of a user by `2^248 - 1` without updating the total supply.
-    /// @dev Assumes that `delegatee` has `>=(2^248 - 1)` tokens, will revert otherwise.
     /// @dev This is controlled by the Panoptic Pool - not individual users.
+    /// @dev If the user's balance is less than `2^248 - 1` (i.e., some phantom shares were consumed
+    /// during the delegation period, e.g., by interest payments), their balance is zeroed and
+    /// `_internalSupply` is increased to compensate for the phantom shares that were incorrectly
+    /// deducted by `_burn` operations during the delegation period.
     /// @param delegatee The account to decrease the balance of
     function revoke(address delegatee) external onlyPanopticPool {
-        balanceOf[delegatee] -= type(uint248).max;
+        uint256 balance = balanceOf[delegatee];
+        if (type(uint248).max > balance) {
+            // Phantom shares were consumed during delegation (e.g., burned for interest).
+            // This can happen when the user owed more interest than their real balance
+            // at the time delegate() was called. Zero the balance and restore
+            // _internalSupply for the overcounted burn.
+            balanceOf[delegatee] = 0;
+            _internalSupply += type(uint248).max - balance;
+        } else {
+            // Normal case: user still has all phantom shares plus any real shares
+            balanceOf[delegatee] = balance - type(uint248).max;
+        }
     }
 
     /// @notice Settles liquidation bonus and returns remaining virtual shares to the protocol.
@@ -939,39 +1270,53 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
             unchecked {
                 bonusAbs = uint256(-bonus);
             }
+            address _poolManager = address(poolManager());
 
+            if (_poolManager == address(0)) {
+                uint256 underlyingTokenBalance = ERC20Minimal(underlyingToken()).balanceOf(
+                    liquidator
+                );
+                if (underlyingTokenBalance < bonusAbs)
+                    revert Errors.NotEnoughTokens(
+                        underlyingToken(),
+                        bonusAbs,
+                        underlyingTokenBalance
+                    );
+                SafeTransferLib.safeTransferFrom(
+                    underlyingToken(),
+                    liquidator,
+                    msg.sender,
+                    bonusAbs
+                );
+            }
             _mint(liquidatee, convertToShares(bonusAbs));
 
-            s_poolAssets += uint128(bonusAbs);
+            s_depositedAssets += uint128(bonusAbs);
 
             uint256 liquidateeBalance = balanceOf[liquidatee];
 
             if (type(uint248).max > liquidateeBalance) {
                 balanceOf[liquidatee] = 0;
-                unchecked {
-                    totalSupply += type(uint248).max - liquidateeBalance;
-                }
+                // keep checked to catch under/overflows
+                _internalSupply += type(uint248).max - liquidateeBalance;
             } else {
-                unchecked {
-                    balanceOf[liquidatee] = liquidateeBalance - type(uint248).max;
-                }
+                // keep checked to catch under/overflows
+                balanceOf[liquidatee] = liquidateeBalance - type(uint248).max;
+            }
+            if (_poolManager != address(0)) {
+                _settleCurrencyDelta(liquidator, int256(bonusAbs));
             }
-
-            _settleCurrencyDelta(liquidator, int256(bonusAbs));
         } else {
             uint256 liquidateeBalance = balanceOf[liquidatee];
 
             if (type(uint248).max > liquidateeBalance) {
-                unchecked {
-                    totalSupply += type(uint248).max - liquidateeBalance;
-                }
+                // keep checked to catch under/overflows
+                _internalSupply += type(uint248).max - liquidateeBalance;
                 liquidateeBalance = 0;
             } else {
-                unchecked {
-                    liquidateeBalance -= type(uint248).max;
-                }
+                // keep checked to catch under/overflows
+                liquidateeBalance -= type(uint248).max;
             }
-
             balanceOf[liquidatee] = liquidateeBalance;
 
             uint256 bonusShares = convertToShares(uint256(bonus));
@@ -993,20 +1338,20 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
                 // N = (ZY - ZT) / (X - Z)
                 // N = Z(Y - T) / (X - Z)
                 // subtract delegatee balance from N since it was already transferred to the delegator
-                uint256 _totalSupply = totalSupply;
-                unchecked {
-                    _mint(
-                        liquidator,
-                        Math.min(
-                            Math.mulDivCapped(
-                                uint256(bonus),
-                                _totalSupply - liquidateeBalance,
-                                uint256(Math.max(1, int256(totalAssets()) - bonus))
-                            ) - liquidateeBalance,
-                            _totalSupply * DECIMALS
-                        )
-                    );
-                }
+                uint256 _totalSupply = totalSupply();
+
+                // keep checked to catch any casting/math errors
+                _mint(
+                    liquidator,
+                    Math.min(
+                        Math.mulDivCapped(
+                            uint256(bonus),
+                            _totalSupply - liquidateeBalance,
+                            uint256(Math.max(1, int256(totalAssets()) - bonus))
+                        ) - liquidateeBalance,
+                        _totalSupply * DECIMALS
+                    )
+                );
             } else {
                 _transferFrom(liquidatee, liquidator, bonusShares);
             }
@@ -1025,9 +1370,14 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
         if (assets > 0) {
             _transferFrom(refunder, refundee, convertToShares(uint256(assets)));
         } else {
-            unchecked {
-                _transferFrom(refundee, refunder, convertToShares(uint256(-assets)));
-            }
+            uint256 sharesToTransfer = convertToShares(uint256(-assets));
+            if (balanceOf[refundee] < sharesToTransfer)
+                revert Errors.NotEnoughTokens(
+                    address(this),
+                    uint256(-assets),
+                    convertToAssets(balanceOf[refundee])
+                );
+            _transferFrom(refundee, refunder, sharesToTransfer);
         }
     }
 
@@ -1035,597 +1385,280 @@ contract CollateralTracker is Clone, ERC20Minimal, Multicall {
                      OPTION EXERCISE AND COMMISSION
     //////////////////////////////////////////////////////////////*/
 
-    /// @notice Take commission and settle ITM amounts on option creation.
+    /// @notice Internal function to handle all balance and state updates for position creation and closing.
+    /// @param isCreation A boolean flag to indicate if this is for option creation (true) or closing (false).
     /// @param optionOwner The user minting the option
     /// @param longAmount The amount of longs
     /// @param shortAmount The amount of shorts
-    /// @param swappedAmount The amount of tokens moved during creation of the option position
-    /// @param isCovered Whether the option was minted as covered (no swap occurred if ITM)
-    /// @return The final utilization of the collateral vault
-    /// @return The total amount of commission (base rate + ITM spread) paid
-    function takeCommissionAddData(
+    /// @param ammDeltaAmount The amount of tokens moved during creation of the option position
+    ///
+    function _updateBalancesAndSettle(
         address optionOwner,
+        bool isCreation,
         int128 longAmount,
         int128 shortAmount,
-        int128 swappedAmount,
-        bool isCovered
-    ) external onlyPanopticPool returns (uint32, uint128) {
+        int128 ammDeltaAmount,
+        int128 realizedPremium
+    ) internal returns (uint32, int128, uint256, uint256) {
+        _accrueInterest(optionOwner, IS_NOT_DEPOSIT);
+        /// Snapshot state variables to compute the price per share
+        uint256 _totalAssets = totalAssets();
+        uint256 _totalSupply = totalSupply();
+
+        int128 netBorrows;
+        int256 tokenToPay;
         unchecked {
-            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
-            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;
-
-            (int256 tokenToPay, uint128 commission) = _getExchangedAmount(
-                longAmount,
-                shortAmount,
-                swappedAmount,
-                isCovered
-            );
-
-            // compute tokens to be paid due to swap
-            // mint or burn tokens due to minting in-the-money
-            if (tokenToPay > 0) {
-                // if user must pay tokens, burn them from user balance
-                uint256 sharesToBurn = Math.mulDivRoundingUp(
-                    uint256(tokenToPay),
-                    totalSupply,
-                    totalAssets()
-                );
-                _burn(optionOwner, sharesToBurn);
-            } else if (tokenToPay < 0) {
-                // if user must receive tokens, mint them
-                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
-                _mint(optionOwner, sharesToMint);
+            // cannot miscast because all values are larger than 0
+            netBorrows = isCreation ? shortAmount - longAmount : longAmount - shortAmount;
+            tokenToPay = int256(ammDeltaAmount) - netBorrows - realizedPremium;
+        }
+        {
+            // compute creditDelta with the snapshotted values
+            uint256 creditDelta;
+            if (longAmount > 0) {
+                unchecked {
+                    // cannot miscast because longAmount ?= 0
+                    creditDelta = isCreation
+                        ? Math.mulDivRoundingUp(
+                            uint256(uint128(longAmount)),
+                            _totalSupply,
+                            _totalAssets
+                        )
+                        : Math.mulDiv(uint256(uint128(longAmount)), _totalSupply, _totalAssets);
+                }
+            }
+            if (!isCreation) {
+                if (creditDelta > 0) {
+                    // update s_creditedShares: add long amounts == tokens moved into AMM or received when the position is closed
+                    //
+                    // An underflow is possible because Uniswap rounds long position DOWN when minting and UP when burning LP positions.
+                    // For examples, for a long position, the amount of credited shares at MINT will be lower than the ones repaid back at BURN,
+                    // which means the s_creditedShares tracker will become negative (the protocol lost ~1 asset worth of shares).
+                    // Consequently, those shares must also be burnt, and we're making those shares come out of the option owner.
+                    uint256 _creditedShares = s_creditedShares;
+                    if (_creditedShares < creditDelta) {
+                        s_creditedShares = 0;
+                        // add the rounding haircut paid by the option owner at close
+                        // rounding up again during conversion potentially add another `1` extra share as ceil*ceil is not idempotent
+                        unchecked {
+                            // can never miscast because  creditDelta > _creditedShares
+                            tokenToPay += int256(
+                                uint256(
+                                    Math
+                                        .mulDivRoundingUp(
+                                            creditDelta - _creditedShares,
+                                            _totalAssets,
+                                            _totalSupply
+                                        )
+                                        .toUint128()
+                                )
+                            );
+                        }
+                    } else {
+                        // keep unchecked to catch underflows
+                        s_creditedShares -= creditDelta;
+                    }
+                }
+            } else {
+                if (creditDelta > 0) {
+                    // update s_creditedShares: Add long amounts == tokens moved out of AMM or paid when creating credits
+                    // keep unchecked to catch overflows
+                    s_creditedShares += creditDelta;
+                }
+                // pay commission only when opening a new position, return notional value
             }
-
-            // update stored asset balances with net moved amounts
-            // the inflow or outflow of pool assets is defined by the swappedAmount: it includes both the ITM swap amounts and the short/long amounts used to create the position
-            // however, any intrinsic value is paid for by the users, so we only add the portion that comes from PLPs: the short/long amounts
-            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
-            s_poolAssets = uint256(updatedAssets).toUint128();
-            s_inAMM = uint256(int256(uint256(s_inAMM)) + (shortAmount - longAmount)).toUint128();
-
-            return (uint32(_poolUtilization()), commission);
         }
-    }
-
-    /// @notice Exercise an option and pay to the seller what is owed from the buyer.
-    /// @dev Called when a position is burnt because it may need to be exercised.
-    /// @param optionOwner The owner of the option being burned
-    /// @param longAmount The notional value of the long legs of the position (if any)
-    /// @param shortAmount The notional value of the short legs of the position (if any)
-    /// @param swappedAmount The amount of tokens moved during the option close
-    /// @param realizedPremium Premium to settle on the current positions
-    /// @return The amount of tokens paid when closing that position
-    function exercise(
-        address optionOwner,
-        int128 longAmount,
-        int128 shortAmount,
-        int128 swappedAmount,
-        int128 realizedPremium
-    ) external onlyPanopticPool returns (int128) {
-        unchecked {
-            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
-            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;
 
-            // add premium and token deltas not covered by swap to be paid/collected on position close
-            int256 tokenToPay = int256(swappedAmount) -
-                (longAmount - shortAmount) -
-                realizedPremium;
+        address _optionOwner = optionOwner;
+        // Mint/Burn Shares
+        if (tokenToPay > 0) {
+            uint256 sharesToBurn = Math.mulDivRoundingUp(
+                uint256(tokenToPay),
+                _totalSupply,
+                _totalAssets
+            );
 
-            if (tokenToPay > 0) {
-                // if user must pay tokens, burn them from user balance (revert if balance too small)
-                uint256 sharesToBurn = Math.mulDivRoundingUp(
+            if (balanceOf[_optionOwner] < sharesToBurn)
+                revert Errors.NotEnoughTokens(
+                    address(this),
                     uint256(tokenToPay),
-                    totalSupply,
-                    totalAssets()
-                );
-                _burn(optionOwner, sharesToBurn);
-            } else if (tokenToPay < 0) {
-                // if user must receive tokens, mint them
-                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
-                _mint(optionOwner, sharesToMint);
-            }
-
-            // update stored asset balances with net moved amounts
-            // any intrinsic value is paid for by the users, so we do not add it to s_inAMM
-            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
-            s_poolAssets = uint256(updatedAssets + realizedPremium).toUint128();
-            s_inAMM = uint256(int256(uint256(s_inAMM)) - (shortAmount - longAmount)).toUint128();
-
-            return (int128(tokenToPay));
-        }
-    }
-
-    /// @notice Get the amount exchanged to mint an option, including any fees.
-    /// @param longAmount The amount of long options held
-    /// @param shortAmount The amount of short options held
-    /// @param swappedAmount The amount of tokens moved during creation of the option position
-    /// @param isCovered Whether the option was minted as covered (no swap occurred if ITM)
-    /// @return The amount of funds to be exchanged for minting an option (includes commission, swapFee, and intrinsic value)
-    /// @return The total commission (base rate + ITM spread) paid for minting the option
-    function _getExchangedAmount(
-        int128 longAmount,
-        int128 shortAmount,
-        int128 swappedAmount,
-        bool isCovered
-    ) internal view returns (int256, uint128) {
-        unchecked {
-            int256 intrinsicValue = int256(swappedAmount) - (shortAmount - longAmount);
-
-            // the swap commission is paid on the intrinsic value (if a swap occurred; users who mint covered options with their own collateral do not pay this fee)
-            uint256 commission = Math.unsafeDivRoundingUp(
-                uint256(uint128(shortAmount + longAmount)) * COMMISSION_FEE,
-                DECIMALS
-            ) +
-                (
-                    intrinsicValue == 0 || isCovered
-                        ? 0
-                        : Math.unsafeDivRoundingUp(
-                            ITM_SPREAD_FEE * uint256(Math.abs(intrinsicValue)),
-                            DECIMALS
-                        )
+                    convertToAssets(balanceOf[_optionOwner])
                 );
 
-            return (intrinsicValue + int256(commission), uint128(commission));
+            _burn(_optionOwner, sharesToBurn);
+        } else if (tokenToPay < 0) {
+            uint256 sharesToMint = Math.mulDiv(uint256(-tokenToPay), _totalSupply, _totalAssets);
+            _mint(_optionOwner, sharesToMint);
         }
-    }
-
-    /*//////////////////////////////////////////////////////////////
-                     HEALTH AND COLLATERAL TRACKING
-    //////////////////////////////////////////////////////////////*/
 
-    /// @notice Get the collateral status/margin details of an account/user.
-    /// @dev NOTE: It's up to the caller to confirm from the returned result that the account has enough collateral.
-    /// @dev This can be used to check the health: how many tokens a user has compared to the margin threshold.
-    /// @param user The account to check collateral/margin health for
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param positionBalanceArray The list of all open positions held by the `optionOwner`, stored as `[[tokenId, balance/poolUtilizationAtMint], ...]`
-    /// @param shortPremium The total amount of premium (prorated by available settled tokens) owed to the short legs of `user`
-    /// @param longPremium The total amount of premium owed by the long legs of `user`
-    /// @return Information collected for the tokens about the health of the account
-    /// The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot.
-    function getAccountMarginDetails(
-        address user,
-        int24 atTick,
-        uint256[2][] memory positionBalanceArray,
-        uint128 shortPremium,
-        uint128 longPremium
-    ) public view returns (LeftRightUnsigned) {
-        unchecked {
-            return
-                LeftRightUnsigned
-                    .wrap((convertToAssets(balanceOf[user]) + shortPremium).toUint128())
-                    .toLeftSlot(
-                        positionBalanceArray.length > 0
-                            ? (_getTotalRequiredCollateral(atTick, positionBalanceArray) +
-                                longPremium).toUint128()
-                            : 0
-                    );
+        // Update Pool Assets
+        // use current available assets belonging to PLPs (updated after settlement)
+        /// @dev realizedPremium is 0 for mints, so can add it here
+        // keep checked to prevent under/overflow
+        s_depositedAssets = uint256(
+            int256(uint256(s_depositedAssets)) - ammDeltaAmount + realizedPremium
+        ).toUint128();
+
+        // Update s_assetsInAMM:
+        // isCreation: Add short amounts == tokens moved into the AMM or used to create loans
+        // !isCreation: remove short amounts == tokens moved out of the AMM or repaid when the position is closed
+        // keep checked to catch miscast
+        {
+            int256 newAssetsInAmm = int256(uint256(s_assetsInAMM));
+            newAssetsInAmm += isCreation ? int256(shortAmount) : -int256(shortAmount);
+            s_assetsInAMM = uint256(newAssetsInAmm).toUint128();
         }
-    }
-
-    /// @notice Get the total required amount of collateral tokens of a user/account across all active positions to stay above the margin requirement.
-    /// @dev Returns the token amounts required for the entire account with active positions in `positionIdList` (list of tokenIds).
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param positionBalanceArray The list of all open positions held by the `optionOwner`, stored as `[[tokenId, balance/poolUtilizationAtMint], ...]`
-    /// @return tokenRequired The amount of tokens required to stay above the margin threshold for all active positions of user
-    function _getTotalRequiredCollateral(
-        int24 atTick,
-        uint256[2][] memory positionBalanceArray
-    ) internal view returns (uint256 tokenRequired) {
-        uint256 totalIterations = positionBalanceArray.length;
-        for (uint256 i = 0; i < totalIterations; ) {
-            TokenId tokenId = TokenId.wrap(positionBalanceArray[i][0]);
-
-            uint128 positionSize = PositionBalance.wrap(positionBalanceArray[i][1]).positionSize();
-
-            bool underlyingIsCurrency0 = _underlyingIsCurrency0();
-
-            int16 poolUtilization = underlyingIsCurrency0
-                ? int16(PositionBalance.wrap(positionBalanceArray[i][1]).utilization0())
-                : int16(PositionBalance.wrap(positionBalanceArray[i][1]).utilization1());
-
-            uint256 _tokenRequired = _getRequiredCollateralAtTickSinglePosition(
-                tokenId,
-                positionSize,
-                atTick,
-                poolUtilization,
-                underlyingIsCurrency0
-            );
 
-            unchecked {
-                tokenRequired += _tokenRequired;
-            }
-            unchecked {
-                ++i;
-            }
+        {
+            // add new netBorrows to the left slot
+            s_interestState[_optionOwner] = s_interestState[_optionOwner].addToLeftSlot(netBorrows);
         }
-    }
 
-    /// @notice Get the required amount of collateral tokens corresponding to a specific single position `tokenId` at a price `atTick`.
-    /// @param tokenId The option position
-    /// @param positionSize The size of the option position
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param poolUtilization The utilization of the collateral vault (balance of buying and selling)
-    /// @param underlyingIsCurrency0 Cached `_underlyingIsCurrency0()` value for this CollateralTracker instance
-    /// @return tokenRequired Total required tokens for all legs of the specified tokenId.
-    function _getRequiredCollateralAtTickSinglePosition(
-        TokenId tokenId,
-        uint128 positionSize,
-        int24 atTick,
-        int16 poolUtilization,
-        bool underlyingIsCurrency0
-    ) internal view returns (uint256 tokenRequired) {
-        uint256 numLegs = tokenId.countLegs();
+        // get the utilization, store the current one in transient storage
+        uint32 utilization = uint32(_poolUtilization());
 
-        unchecked {
-            for (uint256 index = 0; index < numLegs; ++index) {
-                if (tokenId.tokenType(index) != (underlyingIsCurrency0 ? 0 : 1)) continue;
-
-                // Increment the tokenRequired accumulator
-                tokenRequired += _getRequiredCollateralSingleLeg(
-                    tokenId,
-                    index,
-                    positionSize,
-                    atTick,
-                    poolUtilization
-                );
-            }
-        }
+        return (utilization, int128(tokenToPay), _totalAssets, _totalSupply);
     }
 
-    /// @notice Calculate the required amount of collateral for a single leg `index` of position `tokenId`.
-    /// @param tokenId The option position
-    /// @param index The leg index (associated with a liquidity chunk) to compute the required collateral for
-    /// @param positionSize The size of the position
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
-    /// @return required The required amount collateral needed for this leg `index`
-    function _getRequiredCollateralSingleLeg(
-        TokenId tokenId,
-        uint256 index,
-        uint128 positionSize,
-        int24 atTick,
-        int16 poolUtilization
-    ) internal view returns (uint256 required) {
-        return
-            tokenId.riskPartner(index) == index // does this leg have a risk partner? Affects required collateral
-                ? _getRequiredCollateralSingleLegNoPartner(
-                    tokenId,
-                    index,
-                    positionSize,
-                    atTick,
-                    poolUtilization
-                )
-                : _getRequiredCollateralSingleLegPartner(
-                    tokenId,
-                    index,
-                    positionSize,
-                    atTick,
-                    poolUtilization
-                );
-    }
-
-    /// @notice Calculate the required amount of collateral for leg `index` of position `tokenId` when the leg does not have a risk partner.
-    /// @param tokenId The option position
-    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
-    /// @param positionSize The size of the position
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param poolUtilization The pool utilization: ratio of how much funds are in the Panoptic pool versus the AMM pool
-    /// @return required The required amount collateral needed for this leg `index`
-    function _getRequiredCollateralSingleLegNoPartner(
-        TokenId tokenId,
-        uint256 index,
-        uint128 positionSize,
-        int24 atTick,
-        int16 poolUtilization
-    ) internal view returns (uint256 required) {
-        // extract the tokenType (currency0 or currency1)
-        uint256 tokenType = tokenId.tokenType(index);
-
-        // compute the total amount of funds moved for that position
-        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);
-
-        // amount moved is right slot if tokenType=0, left slot otherwise
-        uint128 amountMoved = tokenType == 0 ? amountsMoved.rightSlot() : amountsMoved.leftSlot();
-
-        uint256 isLong = tokenId.isLong(index);
-
-        // start with base requirement, which is based on isLong value
-        required = _getRequiredCollateralAtUtilization(amountMoved, isLong, poolUtilization);
-
-        // if the position is long, required tokens do not depend on price
-        unchecked {
-            if (isLong == 0) {
-                // if position is short, check whether the position is out-the-money
-
-                (int24 tickLower, int24 tickUpper) = tokenId.asTicks(index);
-
-                // compute the collateral requirement as a fixed amount that doesn't depend on price
-                if (
-                    ((atTick >= tickUpper) && (tokenType == 1)) || // strike OTM when price >= upperTick for tokenType=1
-                    ((atTick < tickLower) && (tokenType == 0)) // strike OTM when price < lowerTick for tokenType=0
-                ) {
-                    // position is out-of-the-money, collateral requirement = SCR * amountMoved
-                    required;
-                } else {
-                    int24 strike = tokenId.strike(index);
-                    // if position is ITM or ATM, then the collateral requirement depends on price:
-
-                    // compute the ratio of strike to price for calls (or price to strike for puts)
-                    // (- and * 2 in tick space are / and ^ 2 in price space so sqrtRatioAtTick(2 *(a - b)) = a/b (*2^96)
-                    // both of these ratios decrease as the position becomes deeper ITM, and it is possible
-                    // for the ratio of the prices to go under the minimum price
-                    // (which is the limit of what getSqrtRatioAtTick supports)
-                    // so instead we cap it at the minimum price, which is acceptable because
-                    // a higher ratio will result in an increased slope for the collateral requirement
-                    uint160 ratio = tokenType == 1 // tokenType
-                        ? Math.getSqrtRatioAtTick(
-                            Math.max24(2 * (atTick - strike), Constants.MIN_V4POOL_TICK)
-                        ) // puts ->  price/strike
-                        : Math.getSqrtRatioAtTick(
-                            Math.max24(2 * (strike - atTick), Constants.MIN_V4POOL_TICK)
-                        ); // calls -> strike/price
-
-                    // compute the collateral requirement depending on whether the position is ITM & out-of-range or ITM and in-range:
-
-                    /// ITM and out-of-range
-                    if (
-                        ((atTick < tickLower) && (tokenType == 1)) || // strike ITM but out of range price < lowerTick for tokenType=1
-                        ((atTick >= tickUpper) && (tokenType == 0)) // strike ITM but out of range when price >= upperTick for tokenType=0
-                    ) {
-                        /*
-                                    Short put BPR = 100% - (price/strike) + SCR
-
-                           BUYING
-                           POWER
-                           REQUIREMENT
-                         
-                                         ^               .         .
-                                         |        <- ITM . <-ATM-> . OTM ->
-                           100% + SCR% - |--__           .    .    .
-                                  100% - | . .¯¯--__     .    .    .
-                                         |    .     ¯¯--__    .    .
-                                   SCR - |    .          .¯¯--__________
-                                         |    .          .    .    .
-                                         +----+----------+----+----+--->   current
-                                         0   Liqui-     Pa  strike Pb       price
-                                             dation
-                                             price = SCR*strike                                         
-                         */
-
-                        uint256 c2 = Constants.FP96 - ratio;
-
-                        // compute the tokens required
-                        // position is in-the-money, collateral requirement = amountMoved*(1-ratio) + SCR*amountMoved
-                        required += Math.mulDiv96RoundingUp(amountMoved, c2);
-                    } else {
-                        // position is in-range (ie. current tick is between upper+lower tick): we draw a line between the
-                        // collateral requirement at the lowerTick and the one at the upperTick. We use that interpolation as
-                        // the collateral requirement when in-range, which always over-estimates the amount of token required
-                        // Specifically:
-                        //  required = amountMoved * (scaleFactor - ratio) / (scaleFactor + 1) + sellCollateralRatio*amountMoved
-                        uint160 scaleFactor = Math.getSqrtRatioAtTick(
-                            (tickUpper - strike) + (strike - tickLower)
-                        );
-                        uint256 c3 = Math.mulDivRoundingUp(
-                            amountMoved,
-                            scaleFactor - ratio,
-                            scaleFactor + Constants.FP96
-                        );
+    /// @notice Take commission and settle ITM amounts on option creation.
+    /// @param optionOwner The user minting the option
+    /// @param longAmount The amount of longs
+    /// @param shortAmount The amount of shorts
+    /// @param ammDeltaAmount The amount of tokens moved during creation of the option position
+    /// @param riskParameters The RiskEngine's core parameters
+    /// @return utilization The final utilization of the collateral vault (in basis points)
+    /// @return tokenPaid The total amount of tokens paid by the option owner (negative if tokens were received)
+    function settleMint(
+        address optionOwner,
+        int128 longAmount,
+        int128 shortAmount,
+        int128 ammDeltaAmount,
+        RiskParameters riskParameters
+    ) external onlyPanopticPool returns (uint32, int128) {
+        (
+            uint32 utilization,
+            int128 tokenPaid,
+            uint256 _totalAssets,
+            uint256 _totalSupply
+        ) = _updateBalancesAndSettle(
+                optionOwner,
+                true, // isCreation = true
+                longAmount,
+                shortAmount,
+                ammDeltaAmount,
+                0 // realizedPremium not used
+            );
 
-                        required += c3;
-                    }
+        {
+            uint128 commission = uint256(int256(shortAmount) + int256(longAmount)).toUint128();
+            uint128 commissionFee = Math
+                .mulDivRoundingUp(commission, riskParameters.notionalFee(), DECIMALS)
+                .toUint128();
+            uint256 sharesToBurn = Math.mulDivRoundingUp(commissionFee, _totalSupply, _totalAssets);
+            if (riskParameters.feeRecipient() == 0) {
+                _burn(optionOwner, sharesToBurn);
+                emit CommissionPaid(optionOwner, address(0), commissionFee, 0);
+            } else {
+                unchecked {
+                    _transferFrom(
+                        optionOwner,
+                        address(riskEngine()),
+                        (sharesToBurn * riskParameters.protocolSplit()) / DECIMALS
+                    );
+                    _transferFrom(
+                        optionOwner,
+                        address(uint160(riskParameters.feeRecipient())),
+                        (sharesToBurn * riskParameters.builderSplit()) / DECIMALS
+                    );
+                    emit CommissionPaid(
+                        optionOwner,
+                        address(uint160(riskParameters.feeRecipient())),
+                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS),
+                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS)
+                    );
                 }
             }
         }
-    }
 
-    /// @notice Calculate the required amount of collateral for leg `index` for position `tokenId` accounting for its partner leg.
-    /// @dev If the two `isLong` fields are different (i.e., a short leg and a long leg are partnered) but the tokenTypes are the same, this is a spread.
-    /// @dev A spread is a defined risk position which has a max loss given by difference between the long and short strikes.
-    /// @dev If the two `isLong` fields are the same but the tokenTypes are different (one is a call, the other a put, e.g.), this is a strangle -
-    /// a strangle benefits from enhanced capital efficiency because only one side can be ITM at any given time.
-    /// @param tokenId The option position
-    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
-    /// @param positionSize The size of the position
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
-    /// @return required The required amount of collateral needed for this leg `index`
-    function _getRequiredCollateralSingleLegPartner(
-        TokenId tokenId,
-        uint256 index,
-        uint128 positionSize,
-        int24 atTick,
-        int16 poolUtilization
-    ) internal view returns (uint256 required) {
-        // extract partner index (associated with another liquidity chunk)
-        uint256 partnerIndex = tokenId.riskPartner(index);
-
-        uint256 isLong = tokenId.isLong(index);
-        if (isLong != tokenId.isLong(partnerIndex)) {
-            if (isLong == 1) {
-                required = _computeSpread(
-                    tokenId,
-                    positionSize,
-                    index,
-                    partnerIndex,
-                    poolUtilization
-                );
-            }
-        } else {
-            required = _computeStrangle(tokenId, index, positionSize, atTick, poolUtilization);
-        }
+        return (utilization, tokenPaid);
     }
 
-    /// @notice Get the base collateral requirement for a position of notional value `amount` at the current Panoptic pool `utilization` level.
-    /// @param amount The amount to multiply by the base collateral ratio
-    /// @param isLong Whether the position is long (=1) or short (=0)
-    /// @param utilization The utilization of the Panoptic pool (balance between sellers and buyers)
-    /// @return required The base collateral requirement corresponding to the incoming `amount`
-    function _getRequiredCollateralAtUtilization(
-        uint128 amount,
-        uint256 isLong,
-        int16 utilization
-    ) internal view returns (uint256 required) {
-        // if position is short, use sell collateral ratio
-        if (isLong == 0) {
-            // compute the sell collateral ratio, which depends on the pool utilization
-            uint256 sellCollateral = _sellCollateralRatio(utilization);
-
-            // compute required as amount*collateralRatio
-            // can use unsafe because denominator is always nonzero
-            unchecked {
-                required = Math.unsafeDivRoundingUp(amount * sellCollateral, DECIMALS);
-            }
-        } else if (isLong == 1) {
-            // if options is long, use buy collateral ratio
-            // compute the buy collateral ratio, which depends on the pool utilization
-            uint256 buyCollateral = _buyCollateralRatio(uint16(utilization));
-
-            // compute required as amount*collateralRatio
-            // can use unsafe because denominator is always nonzero
-            unchecked {
-                required = Math.unsafeDivRoundingUp(amount * buyCollateral, DECIMALS);
-            }
-        }
-    }
-
-    /// @notice Calculate the required amount of collateral for the spread portion of the spread position.
-    /// @dev `max(long leg requirement, 100% collateralized risk)`
-    /// @dev May be higher than the requirement of an equivalent pair of non-risk-partnered legs if the spread is very wide (risky).
-    /// @param tokenId The option position
-    /// @param positionSize The size of the position
-    /// @param index The leg index of the LONG leg in the spread position
-    /// @param partnerIndex The index of the partnered SHORT leg in the spread position
-    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
-    /// @return spreadRequirement The required amount of collateral needed for the spread
-    function _computeSpread(
-        TokenId tokenId,
-        uint128 positionSize,
-        uint256 index,
-        uint256 partnerIndex,
-        int16 poolUtilization
-    ) internal view returns (uint256 spreadRequirement) {
-        // compute the total amount of funds moved for the position's current leg
-        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);
-
-        // compute the total amount of funds moved for the position's partner leg
-        LeftRightUnsigned amountsMovedPartner = PanopticMath.getAmountsMoved(
-            tokenId,
-            positionSize,
-            partnerIndex
+    /// @notice Exercise an option and pay to the seller what is owed from the buyer.
+    /// @dev Called when a position is burnt because it may need to be exercised.
+    /// @param optionOwner The owner of the option being burned
+    /// @param longAmount The notional value of the long legs of the position (if any)
+    /// @param shortAmount The notional value of the short legs of the position (if any)
+    /// @param ammDeltaAmount The amount of tokens moved during the option close
+    /// @param realizedPremium Premium to settle on the current positions
+    /// @param riskParameters The RiskEngine's core risk parameters
+    /// @return The amount of tokens paid when closing that position
+    function settleBurn(
+        address optionOwner,
+        int128 longAmount,
+        int128 shortAmount,
+        int128 ammDeltaAmount,
+        int128 realizedPremium,
+        RiskParameters riskParameters
+    ) external onlyPanopticPool returns (int128) {
+        (, int128 tokenPaid, uint256 _totalAssets, uint256 _totalSupply) = _updateBalancesAndSettle(
+            optionOwner,
+            false, // isCreation = false
+            longAmount,
+            shortAmount,
+            ammDeltaAmount,
+            realizedPremium
         );
 
-        uint128 movedRight = amountsMoved.rightSlot();
-        uint128 movedLeft = amountsMoved.leftSlot();
-
-        uint128 movedPartnerRight = amountsMovedPartner.rightSlot();
-        uint128 movedPartnerLeft = amountsMovedPartner.leftSlot();
-
-        uint256 tokenType = tokenId.tokenType(index);
-
-        // compute the max loss of the spread
-
-        // if asset is NOT the same as the tokenType, the required amount is simply the difference in notional values
-        // ie. asset = 1, tokenType = 0:
-        if (tokenId.asset(index) != tokenType) {
-            unchecked {
-                // always take the absolute values of the difference of amounts moved
-                if (tokenType == 0) {
-                    spreadRequirement = movedRight < movedPartnerRight
-                        ? movedPartnerRight - movedRight
-                        : movedRight - movedPartnerRight;
-                } else {
-                    spreadRequirement = movedLeft < movedPartnerLeft
-                        ? movedPartnerLeft - movedLeft
-                        : movedLeft - movedPartnerLeft;
+        if (realizedPremium != 0) {
+            uint128 commissionFee;
+            // compute the minimum of the notionalFee and the premiumFee
+            {
+                uint128 commissionP;
+                unchecked {
+                    commissionP = realizedPremium > 0
+                        ? uint128(realizedPremium)
+                        : uint128(-realizedPremium);
                 }
-            }
-        } else {
-            unchecked {
-                uint256 notional;
-                uint256 notionalP;
-                uint128 contracts;
-                if (tokenType == 1) {
-                    notional = movedRight;
-                    notionalP = movedPartnerRight;
-                    contracts = movedLeft;
-                } else {
-                    notional = movedLeft;
-                    notionalP = movedPartnerLeft;
-                    contracts = movedRight;
+                uint128 commissionFeeP = Math
+                    .mulDivRoundingUp(commissionP, riskParameters.premiumFee(), DECIMALS)
+                    .toUint128();
+                uint128 commissionN = uint256(int256(shortAmount) + int256(longAmount)).toUint128();
+                uint128 commissionFeeN;
+                unchecked {
+                    commissionFeeN = Math
+                        .mulDivRoundingUp(commissionN, 10 * riskParameters.notionalFee(), DECIMALS)
+                        .toUint128();
                 }
-                // the required amount is the amount of contracts multiplied by (notional1 - notional2)/min(notional1, notional2)
-                // can use unsafe because denominator is always nonzero
-                spreadRequirement = (notional < notionalP)
-                    ? Math.unsafeDivRoundingUp((notionalP - notional) * contracts, notional)
-                    : Math.unsafeDivRoundingUp((notional - notionalP) * contracts, notionalP);
+                commissionFee = Math.min(commissionFeeP, commissionFeeN).toUint128();
             }
-        }
-
-        // calculate the spread requirement as max(max_loss, long_leg_col_req)
-        // narrower spreads will be very capital efficient (up to only ~5% of non-partnered CR!), but
-        // wider spreads (an uncommon position w/ high max loss) may not benefit from risk partnering
-        spreadRequirement = Math.max(
-            spreadRequirement,
-            _getRequiredCollateralAtUtilization(
-                tokenType == 0 ? movedRight : movedLeft,
-                1,
-                poolUtilization
-            )
-        );
-    }
 
-    /// @notice Calculate the required amount of collateral for a strangle leg.
-    /// @dev The base collateral requirement is halved for short strangles.
-    /// @dev A strangle can only have only one of its legs ITM at any given time, so this reduces the total risk and collateral requirement.
-    /// @param tokenId The option position
-    /// @param positionSize The size of the position
-    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
-    /// @param atTick The tick at which to evaluate the account's positions
-    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
-    /// @return strangleRequired The required amount of collateral needed for the strangle leg
-    function _computeStrangle(
-        TokenId tokenId,
-        uint256 index,
-        uint128 positionSize,
-        int24 atTick,
-        int16 poolUtilization
-    ) internal view returns (uint256 strangleRequired) {
-        // If both tokenTypes are the same, then this is a short strangle.
-        // A strangle is an options strategy in which the investor holds a position
-        // in both a call and a put option with different strike prices,
-        // but with the same expiration date and underlying asset.
-
-        /// collateral requirement is for short strangles depicted:
-        /**
-                    Put side of a short strangle, BPR = 100% - (100% - SCR/2)*(price/strike)
-           BUYING
-           POWER
-           REQUIREMENT
-                         ^                    .
-                         |           <- ITM   .  OTM ->
-                  100% - |--__                .
-                         |    ¯¯--__          .
-                         |          ¯¯--__    .
-                 SCR/2 - |                ¯¯--______ <------ base collateral is half that of a single-leg
-                         +--------------------+--->   current
-                         0                  strike     price
-         */
-        unchecked {
-            // A negative pool utilization is used to denote a position which is a strangle
-            // add 1 to handle poolUtilization = 0
-            poolUtilization = -(poolUtilization == 0 ? int16(1) : poolUtilization);
+            uint256 sharesToBurn = Math.mulDivRoundingUp(commissionFee, _totalSupply, _totalAssets);
 
-            return
-                strangleRequired = _getRequiredCollateralSingleLegNoPartner(
-                    tokenId,
-                    index,
-                    positionSize,
-                    atTick,
-                    poolUtilization
-                );
+            if (riskParameters.feeRecipient() == 0) {
+                _burn(optionOwner, sharesToBurn);
+                emit CommissionPaid(optionOwner, address(0), commissionFee, 0);
+            } else {
+                unchecked {
+                    _transferFrom(
+                        optionOwner,
+                        address(riskEngine()),
+                        (sharesToBurn * riskParameters.protocolSplit()) / DECIMALS
+                    );
+                    _transferFrom(
+                        optionOwner,
+                        address(uint160(riskParameters.feeRecipient())),
+                        (sharesToBurn * riskParameters.builderSplit()) / DECIMALS
+                    );
+                    emit CommissionPaid(
+                        optionOwner,
+                        address(uint160(riskParameters.feeRecipient())),
+                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS),
+                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS)
+                    );
+                }
+            }
         }
+
+        return tokenPaid;
     }
 }